// automatically generated by the FlatBuffers compiler, do not modify
// cangjielint:disable all

// cangjieformat:disable all

package stdx.CHIR.serialize

enum PackageFormat_CHIRTypeKind {
    CHIRTypeKind_INVALID |
    CHIRTypeKind_INT8 |
    CHIRTypeKind_INT16 |
    CHIRTypeKind_INT32 |
    CHIRTypeKind_INT64 |
    CHIRTypeKind_INT_NATIVE |
    CHIRTypeKind_UINT8 |
    CHIRTypeKind_UINT16 |
    CHIRTypeKind_UINT32 |
    CHIRTypeKind_UINT64 |
    CHIRTypeKind_UINT_NATIVE |
    CHIRTypeKind_FLOAT16 |
    CHIRTypeKind_FLOAT32 |
    CHIRTypeKind_FLOAT64 |
    CHIRTypeKind_RUNE |
    CHIRTypeKind_BOOLEAN |
    CHIRTypeKind_UNIT |
    CHIRTypeKind_NOTHING |
    CHIRTypeKind_VOID |
    CHIRTypeKind_TUPLE |
    CHIRTypeKind_STRUCT |
    CHIRTypeKind_ENUM |
    CHIRTypeKind_FUNC |
    CHIRTypeKind_CLASS |
    CHIRTypeKind_RAWARRAY |
    CHIRTypeKind_VARRAY |
    CHIRTypeKind_C_POINTER |
    CHIRTypeKind_C_STRING |
    CHIRTypeKind_GENERIC |
    CHIRTypeKind_REFTYPE |
    CHIRTypeKind_BOXTYPE |
    CHIRTypeKind_THIS
}

func EnumValuesPackageFormat_CHIRTypeKind(e: UInt8) : PackageFormat_CHIRTypeKind {
    var values: Array<PackageFormat_CHIRTypeKind> = [
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INVALID,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INT8,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INT16,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INT32,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INT64,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_INT_NATIVE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT8,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT16,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT32,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT64,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT_NATIVE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT16,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT32,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT64,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_RUNE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_BOOLEAN,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_UNIT,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_NOTHING,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_VOID,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_TUPLE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_STRUCT,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_ENUM,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_FUNC,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_CLASS,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_RAWARRAY,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_VARRAY,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_C_POINTER,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_C_STRING,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_GENERIC,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_REFTYPE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_BOXTYPE,
        PackageFormat_CHIRTypeKind.CHIRTypeKind_THIS
    ]
    return if (e < 32) { values[Int64(e)] } else { CHIRTypeKind_INVALID }
}

func EnumPackageFormat_CHIRTypeKindValues(e: PackageFormat_CHIRTypeKind) : UInt8 {
    return match (e) {
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INVALID => 0
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INT8 => 1
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INT16 => 2
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INT32 => 3
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INT64 => 4
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_INT_NATIVE => 5
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT8 => 6
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT16 => 7
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT32 => 8
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT64 => 9
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UINT_NATIVE => 10
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT16 => 11
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT32 => 12
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_FLOAT64 => 13
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_RUNE => 14
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_BOOLEAN => 15
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_UNIT => 16
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_NOTHING => 17
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_VOID => 18
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_TUPLE => 19
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_STRUCT => 20
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_ENUM => 21
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_FUNC => 22
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_CLASS => 23
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_RAWARRAY => 24
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_VARRAY => 25
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_C_POINTER => 26
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_C_STRING => 27
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_GENERIC => 28
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_REFTYPE => 29
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_BOXTYPE => 30
        case PackageFormat_CHIRTypeKind.CHIRTypeKind_THIS => 31
     }
}

enum PackageFormat_SourceExpr {
    SourceExpr_IF_EXPR |
    SourceExpr_WHILE_EXPR |
    SourceExpr_DO_WHILE_EXPR |
    SourceExpr_MATCH_EXPR |
    SourceExpr_IF_LET_OR_WHILE_LET |
    SourceExpr_QUEST |
    SourceExpr_BINARY |
    SourceExpr_FOR_IN_EXPR |
    SourceExpr_OTHER
}

func EnumValuesPackageFormat_SourceExpr(e: UInt8) : PackageFormat_SourceExpr {
    var values: Array<PackageFormat_SourceExpr> = [
        PackageFormat_SourceExpr.SourceExpr_IF_EXPR,
        PackageFormat_SourceExpr.SourceExpr_WHILE_EXPR,
        PackageFormat_SourceExpr.SourceExpr_DO_WHILE_EXPR,
        PackageFormat_SourceExpr.SourceExpr_MATCH_EXPR,
        PackageFormat_SourceExpr.SourceExpr_IF_LET_OR_WHILE_LET,
        PackageFormat_SourceExpr.SourceExpr_QUEST,
        PackageFormat_SourceExpr.SourceExpr_BINARY,
        PackageFormat_SourceExpr.SourceExpr_FOR_IN_EXPR,
        PackageFormat_SourceExpr.SourceExpr_OTHER
    ]
    return if (e < 9) { values[Int64(e)] } else { SourceExpr_IF_EXPR }
}

func EnumPackageFormat_SourceExprValues(e: PackageFormat_SourceExpr) : UInt8 {
    return match (e) {
        case PackageFormat_SourceExpr.SourceExpr_IF_EXPR => 0
        case PackageFormat_SourceExpr.SourceExpr_WHILE_EXPR => 1
        case PackageFormat_SourceExpr.SourceExpr_DO_WHILE_EXPR => 2
        case PackageFormat_SourceExpr.SourceExpr_MATCH_EXPR => 3
        case PackageFormat_SourceExpr.SourceExpr_IF_LET_OR_WHILE_LET => 4
        case PackageFormat_SourceExpr.SourceExpr_QUEST => 5
        case PackageFormat_SourceExpr.SourceExpr_BINARY => 6
        case PackageFormat_SourceExpr.SourceExpr_FOR_IN_EXPR => 7
        case PackageFormat_SourceExpr.SourceExpr_OTHER => 8
     }
}

enum PackageFormat_Linkage {
    Linkage_WEAK_ODR |
    Linkage_EXTERNAL |
    Linkage_INTERNAL |
    Linkage_LINKONCE_ODR |
    Linkage_EXTERNAL_WEAK
}

func EnumValuesPackageFormat_Linkage(e: Int16) : PackageFormat_Linkage {
    var values: Array<PackageFormat_Linkage> = [
        PackageFormat_Linkage.Linkage_WEAK_ODR,
        PackageFormat_Linkage.Linkage_EXTERNAL,
        PackageFormat_Linkage.Linkage_INTERNAL,
        PackageFormat_Linkage.Linkage_LINKONCE_ODR,
        PackageFormat_Linkage.Linkage_EXTERNAL_WEAK
    ]
    return if (e < 5) { values[Int64(e)] } else { Linkage_WEAK_ODR }
}

func EnumPackageFormat_LinkageValues(e: PackageFormat_Linkage) : Int16 {
    return match (e) {
        case PackageFormat_Linkage.Linkage_WEAK_ODR => 0
        case PackageFormat_Linkage.Linkage_EXTERNAL => 1
        case PackageFormat_Linkage.Linkage_INTERNAL => 2
        case PackageFormat_Linkage.Linkage_LINKONCE_ODR => 3
        case PackageFormat_Linkage.Linkage_EXTERNAL_WEAK => 4
     }
}

enum PackageFormat_SkipKind {
    SkipKind_NO_SKIP |
    SkipKind_SKIP_DCE_WARNING |
    SkipKind_SKIP_FORIN_EXIT |
    SkipKind_SKIP_VIC
}

func EnumValuesPackageFormat_SkipKind(e: UInt8) : PackageFormat_SkipKind {
    var values: Array<PackageFormat_SkipKind> = [
        PackageFormat_SkipKind.SkipKind_NO_SKIP,
        PackageFormat_SkipKind.SkipKind_SKIP_DCE_WARNING,
        PackageFormat_SkipKind.SkipKind_SKIP_FORIN_EXIT,
        PackageFormat_SkipKind.SkipKind_SKIP_VIC
    ]
    return if (e < 4) { values[Int64(e)] } else { SkipKind_NO_SKIP }
}

func EnumPackageFormat_SkipKindValues(e: PackageFormat_SkipKind) : UInt8 {
    return match (e) {
        case PackageFormat_SkipKind.SkipKind_NO_SKIP => 0
        case PackageFormat_SkipKind.SkipKind_SKIP_DCE_WARNING => 1
        case PackageFormat_SkipKind.SkipKind_SKIP_FORIN_EXIT => 2
        case PackageFormat_SkipKind.SkipKind_SKIP_VIC => 3
     }
}

enum PackageFormat_OverflowStrategy {
    OverflowStrategy_NA |
    OverflowStrategy_CHECKED |
    OverflowStrategy_WRAPPING |
    OverflowStrategy_THROWING |
    OverflowStrategy_SATURATING
}

func EnumValuesPackageFormat_OverflowStrategy(e: UInt8) : PackageFormat_OverflowStrategy {
    var values: Array<PackageFormat_OverflowStrategy> = [
        PackageFormat_OverflowStrategy.OverflowStrategy_NA,
        PackageFormat_OverflowStrategy.OverflowStrategy_CHECKED,
        PackageFormat_OverflowStrategy.OverflowStrategy_WRAPPING,
        PackageFormat_OverflowStrategy.OverflowStrategy_THROWING,
        PackageFormat_OverflowStrategy.OverflowStrategy_SATURATING
    ]
    return if (e < 5) { values[Int64(e)] } else { OverflowStrategy_NA }
}

func EnumPackageFormat_OverflowStrategyValues(e: PackageFormat_OverflowStrategy) : UInt8 {
    return match (e) {
        case PackageFormat_OverflowStrategy.OverflowStrategy_NA => 0
        case PackageFormat_OverflowStrategy.OverflowStrategy_CHECKED => 1
        case PackageFormat_OverflowStrategy.OverflowStrategy_WRAPPING => 2
        case PackageFormat_OverflowStrategy.OverflowStrategy_THROWING => 3
        case PackageFormat_OverflowStrategy.OverflowStrategy_SATURATING => 4
     }
}

enum PackageFormat_Annotation {
    Annotation_NONE |
    Annotation_NEEDCHECKARRAYBOUND |
    Annotation_NEEDCHECKCAST |
    Annotation_DEBUGLOCATIONINFO |
    Annotation_DEBUGLOCATIONINFOFORWARNING |
    Annotation_GENERATEDFROMFORIN |
    Annotation_ISAUTOENVCLASS |
    Annotation_ISCAPTUREDCLASSINCC |
    Annotation_LINKTYPEINFO |
    Annotation_SKIPCHECK |
    Annotation_NEVEROVERFLOWINFO |
    Annotation_ENUMCASEINDEX |
    Annotation_VIRMETHODOFFSET |
    Annotation_WRAPPEDRAWMETHOD |
    Annotation_VARIANTTYPECASTWRAPPER |
    Annotation_OVERRIDESRCFUNCTYPE
}

func EnumValuesPackageFormat_Annotation(e: UInt8) : PackageFormat_Annotation {
    var values: Array<PackageFormat_Annotation> = [
        PackageFormat_Annotation.Annotation_NONE,
        PackageFormat_Annotation.Annotation_NEEDCHECKARRAYBOUND,
        PackageFormat_Annotation.Annotation_NEEDCHECKCAST,
        PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFO,
        PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFOFORWARNING,
        PackageFormat_Annotation.Annotation_GENERATEDFROMFORIN,
        PackageFormat_Annotation.Annotation_ISAUTOENVCLASS,
        PackageFormat_Annotation.Annotation_ISCAPTUREDCLASSINCC,
        PackageFormat_Annotation.Annotation_LINKTYPEINFO,
        PackageFormat_Annotation.Annotation_SKIPCHECK,
        PackageFormat_Annotation.Annotation_NEVEROVERFLOWINFO,
        PackageFormat_Annotation.Annotation_ENUMCASEINDEX,
        PackageFormat_Annotation.Annotation_VIRMETHODOFFSET,
        PackageFormat_Annotation.Annotation_WRAPPEDRAWMETHOD,
        PackageFormat_Annotation.Annotation_VARIANTTYPECASTWRAPPER,
        PackageFormat_Annotation.Annotation_OVERRIDESRCFUNCTYPE
    ]
    return if (e < 16) { values[Int64(e)] } else { Annotation_NONE }
}

func EnumPackageFormat_AnnotationValues(e: PackageFormat_Annotation) : UInt8 {
    return match (e) {
        case PackageFormat_Annotation.Annotation_NONE => 0
        case PackageFormat_Annotation.Annotation_NEEDCHECKARRAYBOUND => 1
        case PackageFormat_Annotation.Annotation_NEEDCHECKCAST => 2
        case PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFO => 3
        case PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFOFORWARNING => 4
        case PackageFormat_Annotation.Annotation_GENERATEDFROMFORIN => 5
        case PackageFormat_Annotation.Annotation_ISAUTOENVCLASS => 6
        case PackageFormat_Annotation.Annotation_ISCAPTUREDCLASSINCC => 7
        case PackageFormat_Annotation.Annotation_LINKTYPEINFO => 8
        case PackageFormat_Annotation.Annotation_SKIPCHECK => 9
        case PackageFormat_Annotation.Annotation_NEVEROVERFLOWINFO => 10
        case PackageFormat_Annotation.Annotation_ENUMCASEINDEX => 11
        case PackageFormat_Annotation.Annotation_VIRMETHODOFFSET => 12
        case PackageFormat_Annotation.Annotation_WRAPPEDRAWMETHOD => 13
        case PackageFormat_Annotation.Annotation_VARIANTTYPECASTWRAPPER => 14
        case PackageFormat_Annotation.Annotation_OVERRIDESRCFUNCTYPE => 15
     }
}

enum PackageFormat_ValueKind {
    ValueKind_LITERAL |
    ValueKind_GLOBALVAR |
    ValueKind_PARAMETER |
    ValueKind_IMPORTED_FUNC |
    ValueKind_IMPORTED_VAR |
    ValueKind_LOCALVAR |
    ValueKind_FUNC |
    ValueKind_BLOCK |
    ValueKind_BLOCK_GROUP
}

func EnumValuesPackageFormat_ValueKind(e: UInt8) : PackageFormat_ValueKind {
    var values: Array<PackageFormat_ValueKind> = [
        PackageFormat_ValueKind.ValueKind_LITERAL,
        PackageFormat_ValueKind.ValueKind_GLOBALVAR,
        PackageFormat_ValueKind.ValueKind_PARAMETER,
        PackageFormat_ValueKind.ValueKind_IMPORTED_FUNC,
        PackageFormat_ValueKind.ValueKind_IMPORTED_VAR,
        PackageFormat_ValueKind.ValueKind_LOCALVAR,
        PackageFormat_ValueKind.ValueKind_FUNC,
        PackageFormat_ValueKind.ValueKind_BLOCK,
        PackageFormat_ValueKind.ValueKind_BLOCK_GROUP
    ]
    return if (e < 9) { values[Int64(e)] } else { ValueKind_LITERAL }
}

func EnumPackageFormat_ValueKindValues(e: PackageFormat_ValueKind) : UInt8 {
    return match (e) {
        case PackageFormat_ValueKind.ValueKind_LITERAL => 0
        case PackageFormat_ValueKind.ValueKind_GLOBALVAR => 1
        case PackageFormat_ValueKind.ValueKind_PARAMETER => 2
        case PackageFormat_ValueKind.ValueKind_IMPORTED_FUNC => 3
        case PackageFormat_ValueKind.ValueKind_IMPORTED_VAR => 4
        case PackageFormat_ValueKind.ValueKind_LOCALVAR => 5
        case PackageFormat_ValueKind.ValueKind_FUNC => 6
        case PackageFormat_ValueKind.ValueKind_BLOCK => 7
        case PackageFormat_ValueKind.ValueKind_BLOCK_GROUP => 8
     }
}

enum PackageFormat_ConstantValueKind {
    ConstantValueKind_BOOL |
    ConstantValueKind_RUNE |
    ConstantValueKind_INT |
    ConstantValueKind_FLOAT |
    ConstantValueKind_STRING |
    ConstantValueKind_UNIT |
    ConstantValueKind_NULL |
    ConstantValueKind_FUNC
}

func EnumValuesPackageFormat_ConstantValueKind(e: UInt8) : PackageFormat_ConstantValueKind {
    var values: Array<PackageFormat_ConstantValueKind> = [
        PackageFormat_ConstantValueKind.ConstantValueKind_BOOL,
        PackageFormat_ConstantValueKind.ConstantValueKind_RUNE,
        PackageFormat_ConstantValueKind.ConstantValueKind_INT,
        PackageFormat_ConstantValueKind.ConstantValueKind_FLOAT,
        PackageFormat_ConstantValueKind.ConstantValueKind_STRING,
        PackageFormat_ConstantValueKind.ConstantValueKind_UNIT,
        PackageFormat_ConstantValueKind.ConstantValueKind_NULL,
        PackageFormat_ConstantValueKind.ConstantValueKind_FUNC
    ]
    return if (e < 8) { values[Int64(e)] } else { ConstantValueKind_BOOL }
}

func EnumPackageFormat_ConstantValueKindValues(e: PackageFormat_ConstantValueKind) : UInt8 {
    return match (e) {
        case PackageFormat_ConstantValueKind.ConstantValueKind_BOOL => 0
        case PackageFormat_ConstantValueKind.ConstantValueKind_RUNE => 1
        case PackageFormat_ConstantValueKind.ConstantValueKind_INT => 2
        case PackageFormat_ConstantValueKind.ConstantValueKind_FLOAT => 3
        case PackageFormat_ConstantValueKind.ConstantValueKind_STRING => 4
        case PackageFormat_ConstantValueKind.ConstantValueKind_UNIT => 5
        case PackageFormat_ConstantValueKind.ConstantValueKind_NULL => 6
        case PackageFormat_ConstantValueKind.ConstantValueKind_FUNC => 7
     }
}

enum PackageFormat_FuncKind {
    FuncKind_DEFAULT |
    FuncKind_GETTER |
    FuncKind_SETTER |
    FuncKind_LAMBDA |
    FuncKind_CLASS_CONSTRUCTOR |
    FuncKind_PRIMAL_CLASS_CONSTRUCTOR |
    FuncKind_STRUCT_CONSTRUCTOR |
    FuncKind_PRIMAL_STRUCT_CONSTRUCTOR |
    FuncKind_GLOBALVAR_INIT |
    FuncKind_FINALIZER |
    FuncKind_MAIN_ENTRY |
    FuncKind_ANNOFACTORY_FUNC |
    FuncKind_MACRO_FUNC |
    FuncKind_DEFAULT_PARAMETER_FUNC |
    FuncKind_INSTANCEVAR_INIT
}

func EnumValuesPackageFormat_FuncKind(e: UInt8) : PackageFormat_FuncKind {
    var values: Array<PackageFormat_FuncKind> = [
        PackageFormat_FuncKind.FuncKind_DEFAULT,
        PackageFormat_FuncKind.FuncKind_GETTER,
        PackageFormat_FuncKind.FuncKind_SETTER,
        PackageFormat_FuncKind.FuncKind_LAMBDA,
        PackageFormat_FuncKind.FuncKind_CLASS_CONSTRUCTOR,
        PackageFormat_FuncKind.FuncKind_PRIMAL_CLASS_CONSTRUCTOR,
        PackageFormat_FuncKind.FuncKind_STRUCT_CONSTRUCTOR,
        PackageFormat_FuncKind.FuncKind_PRIMAL_STRUCT_CONSTRUCTOR,
        PackageFormat_FuncKind.FuncKind_GLOBALVAR_INIT,
        PackageFormat_FuncKind.FuncKind_FINALIZER,
        PackageFormat_FuncKind.FuncKind_MAIN_ENTRY,
        PackageFormat_FuncKind.FuncKind_ANNOFACTORY_FUNC,
        PackageFormat_FuncKind.FuncKind_MACRO_FUNC,
        PackageFormat_FuncKind.FuncKind_DEFAULT_PARAMETER_FUNC,
        PackageFormat_FuncKind.FuncKind_INSTANCEVAR_INIT
    ]
    return if (e < 15) { values[Int64(e)] } else { FuncKind_DEFAULT }
}

func EnumPackageFormat_FuncKindValues(e: PackageFormat_FuncKind) : UInt8 {
    return match (e) {
        case PackageFormat_FuncKind.FuncKind_DEFAULT => 0
        case PackageFormat_FuncKind.FuncKind_GETTER => 1
        case PackageFormat_FuncKind.FuncKind_SETTER => 2
        case PackageFormat_FuncKind.FuncKind_LAMBDA => 3
        case PackageFormat_FuncKind.FuncKind_CLASS_CONSTRUCTOR => 4
        case PackageFormat_FuncKind.FuncKind_PRIMAL_CLASS_CONSTRUCTOR => 5
        case PackageFormat_FuncKind.FuncKind_STRUCT_CONSTRUCTOR => 6
        case PackageFormat_FuncKind.FuncKind_PRIMAL_STRUCT_CONSTRUCTOR => 7
        case PackageFormat_FuncKind.FuncKind_GLOBALVAR_INIT => 8
        case PackageFormat_FuncKind.FuncKind_FINALIZER => 9
        case PackageFormat_FuncKind.FuncKind_MAIN_ENTRY => 10
        case PackageFormat_FuncKind.FuncKind_ANNOFACTORY_FUNC => 11
        case PackageFormat_FuncKind.FuncKind_MACRO_FUNC => 12
        case PackageFormat_FuncKind.FuncKind_DEFAULT_PARAMETER_FUNC => 13
        case PackageFormat_FuncKind.FuncKind_INSTANCEVAR_INIT => 14
     }
}

enum PackageFormat_CustomDefKind {
    CustomDefKind_STRUCT |
    CustomDefKind_ENUM |
    CustomDefKind_CLASS |
    CustomDefKind_EXTEND
}

func EnumValuesPackageFormat_CustomDefKind(e: UInt8) : PackageFormat_CustomDefKind {
    var values: Array<PackageFormat_CustomDefKind> = [
        PackageFormat_CustomDefKind.CustomDefKind_STRUCT,
        PackageFormat_CustomDefKind.CustomDefKind_ENUM,
        PackageFormat_CustomDefKind.CustomDefKind_CLASS,
        PackageFormat_CustomDefKind.CustomDefKind_EXTEND
    ]
    return if (e < 4) { values[Int64(e)] } else { CustomDefKind_STRUCT }
}

func EnumPackageFormat_CustomDefKindValues(e: PackageFormat_CustomDefKind) : UInt8 {
    return match (e) {
        case PackageFormat_CustomDefKind.CustomDefKind_STRUCT => 0
        case PackageFormat_CustomDefKind.CustomDefKind_ENUM => 1
        case PackageFormat_CustomDefKind.CustomDefKind_CLASS => 2
        case PackageFormat_CustomDefKind.CustomDefKind_EXTEND => 3
     }
}

enum PackageFormat_ClassDefKind {
    ClassDefKind_CLASS |
    ClassDefKind_INTERFACE
}

func EnumValuesPackageFormat_ClassDefKind(e: Int16) : PackageFormat_ClassDefKind {
    var values: Array<PackageFormat_ClassDefKind> = [
        PackageFormat_ClassDefKind.ClassDefKind_CLASS,
        PackageFormat_ClassDefKind.ClassDefKind_INTERFACE
    ]
    return if (e < 2) { values[Int64(e)] } else { ClassDefKind_CLASS }
}

func EnumPackageFormat_ClassDefKindValues(e: PackageFormat_ClassDefKind) : Int16 {
    return match (e) {
        case PackageFormat_ClassDefKind.ClassDefKind_CLASS => 0
        case PackageFormat_ClassDefKind.ClassDefKind_INTERFACE => 1
     }
}

enum PackageFormat_CHIRExprKind {
    CHIRExprKind_INVALID |
    CHIRExprKind_GOTO |
    CHIRExprKind_BRANCH |
    CHIRExprKind_MULTIBRANCH |
    CHIRExprKind_EXIT |
    CHIRExprKind_APPLY_WITH_EXCEPTION |
    CHIRExprKind_INVOKE_WITH_EXCEPTION |
    CHIRExprKind_INVOKESTATIC_WITH_EXCEPTION |
    CHIRExprKind_RAISE_EXCEPTION |
    CHIRExprKind_INT_OP_WITH_EXCEPTION |
    CHIRExprKind_SPAWN_WITH_EXCEPTION |
    CHIRExprKind_TYPECAST_WITH_EXCEPTION |
    CHIRExprKind_INTRINSIC_WITH_EXCEPTION |
    CHIRExprKind_ALLOCATE_WITH_EXCEPTION |
    CHIRExprKind_RAW_ARRAY_ALLOCATE_WITH_EXCEPTION |
    CHIRExprKind_NEG |
    CHIRExprKind_NOT |
    CHIRExprKind_BITNOT |
    CHIRExprKind_ADD |
    CHIRExprKind_SUB |
    CHIRExprKind_MUL |
    CHIRExprKind_DIV |
    CHIRExprKind_MOD |
    CHIRExprKind_EXP |
    CHIRExprKind_LSHIFT |
    CHIRExprKind_RSHIFT |
    CHIRExprKind_BITAND |
    CHIRExprKind_BITOR |
    CHIRExprKind_BITXOR |
    CHIRExprKind_LT |
    CHIRExprKind_GT |
    CHIRExprKind_LE |
    CHIRExprKind_GE |
    CHIRExprKind_EQUAL |
    CHIRExprKind_NOTEQUAL |
    CHIRExprKind_AND |
    CHIRExprKind_OR |
    CHIRExprKind_ALLOCATE |
    CHIRExprKind_LOAD |
    CHIRExprKind_STORE |
    CHIRExprKind_GET_ELEMENT_REF |
    CHIRExprKind_GET_ELEMENT_BY_NAME |
    CHIRExprKind_STORE_ELEMENT_REF |
    CHIRExprKind_STORE_ELEMENT_BY_NAME |
    CHIRExprKind_IF |
    CHIRExprKind_LOOP |
    CHIRExprKind_FORIN_RANGE |
    CHIRExprKind_FORIN_ITER |
    CHIRExprKind_FORIN_CLOSED_RANGE |
    CHIRExprKind_LAMBDA |
    CHIRExprKind_CONSTANT |
    CHIRExprKind_DEBUGEXPR |
    CHIRExprKind_TUPLE |
    CHIRExprKind_FIELD |
    CHIRExprKind_FIELD_BY_NAME |
    CHIRExprKind_APPLY |
    CHIRExprKind_INVOKE |
    CHIRExprKind_INVOKE_STATIC |
    CHIRExprKind_INSTANCEOF |
    CHIRExprKind_TYPECAST |
    CHIRExprKind_GET_EXCEPTION |
    CHIRExprKind_RAW_ARRAY_ALLOCATE |
    CHIRExprKind_RAW_ARRAY_LITERAL_INIT |
    CHIRExprKind_RAW_ARRAY_INIT_BY_VALUE |
    CHIRExprKind_VARRAY |
    CHIRExprKind_VARRAY_BUILDER |
    CHIRExprKind_INTRINSIC |
    CHIRExprKind_SPAWN |
    CHIRExprKind_GET_INSTANTIATE_VALUE |
    CHIRExprKind_BOX |
    CHIRExprKind_UNBOX |
    CHIRExprKind_TRANSFORM_TO_GENERIC |
    CHIRExprKind_TRANSFORM_TO_CONCRETE |
    CHIRExprKind_UNBOX_TO_REF |
    CHIRExprKind_GET_RTTI |
    CHIRExprKind_GET_RTTI_STATIC
}

func EnumValuesPackageFormat_CHIRExprKind(e: UInt8) : PackageFormat_CHIRExprKind {
    var values: Array<PackageFormat_CHIRExprKind> = [
        PackageFormat_CHIRExprKind.CHIRExprKind_INVALID,
        PackageFormat_CHIRExprKind.CHIRExprKind_GOTO,
        PackageFormat_CHIRExprKind.CHIRExprKind_BRANCH,
        PackageFormat_CHIRExprKind.CHIRExprKind_MULTIBRANCH,
        PackageFormat_CHIRExprKind.CHIRExprKind_EXIT,
        PackageFormat_CHIRExprKind.CHIRExprKind_APPLY_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_INVOKESTATIC_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_RAISE_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_INT_OP_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_SPAWN_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_TYPECAST_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_INTRINSIC_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_ALLOCATE_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_ALLOCATE_WITH_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_NEG,
        PackageFormat_CHIRExprKind.CHIRExprKind_NOT,
        PackageFormat_CHIRExprKind.CHIRExprKind_BITNOT,
        PackageFormat_CHIRExprKind.CHIRExprKind_ADD,
        PackageFormat_CHIRExprKind.CHIRExprKind_SUB,
        PackageFormat_CHIRExprKind.CHIRExprKind_MUL,
        PackageFormat_CHIRExprKind.CHIRExprKind_DIV,
        PackageFormat_CHIRExprKind.CHIRExprKind_MOD,
        PackageFormat_CHIRExprKind.CHIRExprKind_EXP,
        PackageFormat_CHIRExprKind.CHIRExprKind_LSHIFT,
        PackageFormat_CHIRExprKind.CHIRExprKind_RSHIFT,
        PackageFormat_CHIRExprKind.CHIRExprKind_BITAND,
        PackageFormat_CHIRExprKind.CHIRExprKind_BITOR,
        PackageFormat_CHIRExprKind.CHIRExprKind_BITXOR,
        PackageFormat_CHIRExprKind.CHIRExprKind_LT,
        PackageFormat_CHIRExprKind.CHIRExprKind_GT,
        PackageFormat_CHIRExprKind.CHIRExprKind_LE,
        PackageFormat_CHIRExprKind.CHIRExprKind_GE,
        PackageFormat_CHIRExprKind.CHIRExprKind_EQUAL,
        PackageFormat_CHIRExprKind.CHIRExprKind_NOTEQUAL,
        PackageFormat_CHIRExprKind.CHIRExprKind_AND,
        PackageFormat_CHIRExprKind.CHIRExprKind_OR,
        PackageFormat_CHIRExprKind.CHIRExprKind_ALLOCATE,
        PackageFormat_CHIRExprKind.CHIRExprKind_LOAD,
        PackageFormat_CHIRExprKind.CHIRExprKind_STORE,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_ELEMENT_REF,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_ELEMENT_BY_NAME,
        PackageFormat_CHIRExprKind.CHIRExprKind_STORE_ELEMENT_REF,
        PackageFormat_CHIRExprKind.CHIRExprKind_STORE_ELEMENT_BY_NAME,
        PackageFormat_CHIRExprKind.CHIRExprKind_IF,
        PackageFormat_CHIRExprKind.CHIRExprKind_LOOP,
        PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_RANGE,
        PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_ITER,
        PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_CLOSED_RANGE,
        PackageFormat_CHIRExprKind.CHIRExprKind_LAMBDA,
        PackageFormat_CHIRExprKind.CHIRExprKind_CONSTANT,
        PackageFormat_CHIRExprKind.CHIRExprKind_DEBUGEXPR,
        PackageFormat_CHIRExprKind.CHIRExprKind_TUPLE,
        PackageFormat_CHIRExprKind.CHIRExprKind_FIELD,
        PackageFormat_CHIRExprKind.CHIRExprKind_FIELD_BY_NAME,
        PackageFormat_CHIRExprKind.CHIRExprKind_APPLY,
        PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE,
        PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE_STATIC,
        PackageFormat_CHIRExprKind.CHIRExprKind_INSTANCEOF,
        PackageFormat_CHIRExprKind.CHIRExprKind_TYPECAST,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_EXCEPTION,
        PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_ALLOCATE,
        PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_LITERAL_INIT,
        PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_INIT_BY_VALUE,
        PackageFormat_CHIRExprKind.CHIRExprKind_VARRAY,
        PackageFormat_CHIRExprKind.CHIRExprKind_VARRAY_BUILDER,
        PackageFormat_CHIRExprKind.CHIRExprKind_INTRINSIC,
        PackageFormat_CHIRExprKind.CHIRExprKind_SPAWN,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_INSTANTIATE_VALUE,
        PackageFormat_CHIRExprKind.CHIRExprKind_BOX,
        PackageFormat_CHIRExprKind.CHIRExprKind_UNBOX,
        PackageFormat_CHIRExprKind.CHIRExprKind_TRANSFORM_TO_GENERIC,
        PackageFormat_CHIRExprKind.CHIRExprKind_TRANSFORM_TO_CONCRETE,
        PackageFormat_CHIRExprKind.CHIRExprKind_UNBOX_TO_REF,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_RTTI,
        PackageFormat_CHIRExprKind.CHIRExprKind_GET_RTTI_STATIC
    ]
    return if (e < 76) { values[Int64(e)] } else { CHIRExprKind_INVALID }
}

func EnumPackageFormat_CHIRExprKindValues(e: PackageFormat_CHIRExprKind) : UInt8 {
    return match (e) {
        case PackageFormat_CHIRExprKind.CHIRExprKind_INVALID => 0
        case PackageFormat_CHIRExprKind.CHIRExprKind_GOTO => 1
        case PackageFormat_CHIRExprKind.CHIRExprKind_BRANCH => 2
        case PackageFormat_CHIRExprKind.CHIRExprKind_MULTIBRANCH => 3
        case PackageFormat_CHIRExprKind.CHIRExprKind_EXIT => 4
        case PackageFormat_CHIRExprKind.CHIRExprKind_APPLY_WITH_EXCEPTION => 5
        case PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE_WITH_EXCEPTION => 6
        case PackageFormat_CHIRExprKind.CHIRExprKind_INVOKESTATIC_WITH_EXCEPTION => 7
        case PackageFormat_CHIRExprKind.CHIRExprKind_RAISE_EXCEPTION => 8
        case PackageFormat_CHIRExprKind.CHIRExprKind_INT_OP_WITH_EXCEPTION => 9
        case PackageFormat_CHIRExprKind.CHIRExprKind_SPAWN_WITH_EXCEPTION => 10
        case PackageFormat_CHIRExprKind.CHIRExprKind_TYPECAST_WITH_EXCEPTION => 11
        case PackageFormat_CHIRExprKind.CHIRExprKind_INTRINSIC_WITH_EXCEPTION => 12
        case PackageFormat_CHIRExprKind.CHIRExprKind_ALLOCATE_WITH_EXCEPTION => 13
        case PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_ALLOCATE_WITH_EXCEPTION => 14
        case PackageFormat_CHIRExprKind.CHIRExprKind_NEG => 15
        case PackageFormat_CHIRExprKind.CHIRExprKind_NOT => 16
        case PackageFormat_CHIRExprKind.CHIRExprKind_BITNOT => 17
        case PackageFormat_CHIRExprKind.CHIRExprKind_ADD => 18
        case PackageFormat_CHIRExprKind.CHIRExprKind_SUB => 19
        case PackageFormat_CHIRExprKind.CHIRExprKind_MUL => 20
        case PackageFormat_CHIRExprKind.CHIRExprKind_DIV => 21
        case PackageFormat_CHIRExprKind.CHIRExprKind_MOD => 22
        case PackageFormat_CHIRExprKind.CHIRExprKind_EXP => 23
        case PackageFormat_CHIRExprKind.CHIRExprKind_LSHIFT => 24
        case PackageFormat_CHIRExprKind.CHIRExprKind_RSHIFT => 25
        case PackageFormat_CHIRExprKind.CHIRExprKind_BITAND => 26
        case PackageFormat_CHIRExprKind.CHIRExprKind_BITOR => 27
        case PackageFormat_CHIRExprKind.CHIRExprKind_BITXOR => 28
        case PackageFormat_CHIRExprKind.CHIRExprKind_LT => 29
        case PackageFormat_CHIRExprKind.CHIRExprKind_GT => 30
        case PackageFormat_CHIRExprKind.CHIRExprKind_LE => 31
        case PackageFormat_CHIRExprKind.CHIRExprKind_GE => 32
        case PackageFormat_CHIRExprKind.CHIRExprKind_EQUAL => 33
        case PackageFormat_CHIRExprKind.CHIRExprKind_NOTEQUAL => 34
        case PackageFormat_CHIRExprKind.CHIRExprKind_AND => 35
        case PackageFormat_CHIRExprKind.CHIRExprKind_OR => 36
        case PackageFormat_CHIRExprKind.CHIRExprKind_ALLOCATE => 37
        case PackageFormat_CHIRExprKind.CHIRExprKind_LOAD => 38
        case PackageFormat_CHIRExprKind.CHIRExprKind_STORE => 39
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_ELEMENT_REF => 40
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_ELEMENT_BY_NAME => 41
        case PackageFormat_CHIRExprKind.CHIRExprKind_STORE_ELEMENT_REF => 42
        case PackageFormat_CHIRExprKind.CHIRExprKind_STORE_ELEMENT_BY_NAME => 43
        case PackageFormat_CHIRExprKind.CHIRExprKind_IF => 44
        case PackageFormat_CHIRExprKind.CHIRExprKind_LOOP => 45
        case PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_RANGE => 46
        case PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_ITER => 47
        case PackageFormat_CHIRExprKind.CHIRExprKind_FORIN_CLOSED_RANGE => 48
        case PackageFormat_CHIRExprKind.CHIRExprKind_LAMBDA => 49
        case PackageFormat_CHIRExprKind.CHIRExprKind_CONSTANT => 50
        case PackageFormat_CHIRExprKind.CHIRExprKind_DEBUGEXPR => 51
        case PackageFormat_CHIRExprKind.CHIRExprKind_TUPLE => 52
        case PackageFormat_CHIRExprKind.CHIRExprKind_FIELD => 53
        case PackageFormat_CHIRExprKind.CHIRExprKind_FIELD_BY_NAME => 54
        case PackageFormat_CHIRExprKind.CHIRExprKind_APPLY => 55
        case PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE => 56
        case PackageFormat_CHIRExprKind.CHIRExprKind_INVOKE_STATIC => 57
        case PackageFormat_CHIRExprKind.CHIRExprKind_INSTANCEOF => 58
        case PackageFormat_CHIRExprKind.CHIRExprKind_TYPECAST => 59
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_EXCEPTION => 60
        case PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_ALLOCATE => 61
        case PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_LITERAL_INIT => 62
        case PackageFormat_CHIRExprKind.CHIRExprKind_RAW_ARRAY_INIT_BY_VALUE => 63
        case PackageFormat_CHIRExprKind.CHIRExprKind_VARRAY => 64
        case PackageFormat_CHIRExprKind.CHIRExprKind_VARRAY_BUILDER => 65
        case PackageFormat_CHIRExprKind.CHIRExprKind_INTRINSIC => 66
        case PackageFormat_CHIRExprKind.CHIRExprKind_SPAWN => 67
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_INSTANTIATE_VALUE => 68
        case PackageFormat_CHIRExprKind.CHIRExprKind_BOX => 69
        case PackageFormat_CHIRExprKind.CHIRExprKind_UNBOX => 70
        case PackageFormat_CHIRExprKind.CHIRExprKind_TRANSFORM_TO_GENERIC => 71
        case PackageFormat_CHIRExprKind.CHIRExprKind_TRANSFORM_TO_CONCRETE => 72
        case PackageFormat_CHIRExprKind.CHIRExprKind_UNBOX_TO_REF => 73
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_RTTI => 74
        case PackageFormat_CHIRExprKind.CHIRExprKind_GET_RTTI_STATIC => 75
     }
}

enum PackageFormat_IntrinsicKind {
    IntrinsicKind_NOT_INTRINSIC |
    IntrinsicKind_NOT_IMPLEMENTED |
    IntrinsicKind_ARRAY_INIT |
    IntrinsicKind_SIZE_OF |
    IntrinsicKind_ALIGN_OF |
    IntrinsicKind_ARRAY_ACQUIRE_RAW_DATA |
    IntrinsicKind_ARRAY_RELEASE_RAW_DATA |
    IntrinsicKind_ARRAY_BUILT_IN_COPY_TO |
    IntrinsicKind_ARRAY_GET |
    IntrinsicKind_ARRAY_SET |
    IntrinsicKind_ARRAY_GET_UNCHECKED |
    IntrinsicKind_ARRAY_GET_REF_UNCHECKED |
    IntrinsicKind_ARRAY_SET_UNCHECKED |
    IntrinsicKind_ARRAY_SIZE |
    IntrinsicKind_ARRAY_CLONE |
    IntrinsicKind_ARRAY_SLICE_INIT |
    IntrinsicKind_ARRAY_SLICE |
    IntrinsicKind_ARRAY_SLICE_RAWARRAY |
    IntrinsicKind_ARRAY_SLICE_START |
    IntrinsicKind_ARRAY_SLICE_SIZE |
    IntrinsicKind_ARRAY_SLICE_GET_ELEMENT |
    IntrinsicKind_ARRAY_SLICE_GET_ELEMENT_UNCHECKED |
    IntrinsicKind_ARRAY_SLICE_SET_ELEMENT |
    IntrinsicKind_ARRAY_SLICE_SET_ELEMENT_UNCHECKED |
    IntrinsicKind_FILL_IN_STACK_TRACE |
    IntrinsicKind_DECODE_STACK_TRACE |
    IntrinsicKind_DUMP_CURRENT_THREAD_INFO |
    IntrinsicKind_DUMP_ALL_THREADS_INFO |
    IntrinsicKind_CHR |
    IntrinsicKind_ORD |
    IntrinsicKind_CPOINTER_GET_POINTER_ADDRESS |
    IntrinsicKind_CPOINTER_INIT0 |
    IntrinsicKind_CPOINTER_INIT1 |
    IntrinsicKind_CPOINTER_READ |
    IntrinsicKind_CPOINTER_WRITE |
    IntrinsicKind_CPOINTER_ADD |
    IntrinsicKind_CSTRING_INIT |
    IntrinsicKind_CSTRING_CONVERT_CSTR_TO_PTR |
    IntrinsicKind_INOUT_PARAM |
    IntrinsicKind_REGISTER_WATCHED_OBJECT |
    IntrinsicKind_OBJECT_REFEQ |
    IntrinsicKind_RAW_ARRAY_REFEQ |
    IntrinsicKind_FUNC_REFEQ |
    IntrinsicKind_OBJECT_ZERO_VALUE |
    IntrinsicKind_INVOKE_GC |
    IntrinsicKind_SET_GC_THRESHOLD |
    IntrinsicKind_DUMP_CJ_HEAP_DATA |
    IntrinsicKind_GET_GC_COUNT |
    IntrinsicKind_GET_GC_TIME_US |
    IntrinsicKind_GET_GC_FREED_SIZE |
    IntrinsicKind_START_CJ_CPU_PROFILING |
    IntrinsicKind_STOP_CJ_CPU_PROFILING |
    IntrinsicKind_BLACK_BOX |
    IntrinsicKind_GET_MAX_HEAP_SIZE |
    IntrinsicKind_GET_ALLOCATE_HEAP_SIZE |
    IntrinsicKind_GET_REAL_HEAP_SIZE |
    IntrinsicKind_GET_THREAD_NUMBER |
    IntrinsicKind_GET_BLOCKING_THREAD_NUMBER |
    IntrinsicKind_GET_NATIVE_THREAD_NUMBER |
    IntrinsicKind_VARRAY_SET |
    IntrinsicKind_VARRAY_GET |
    IntrinsicKind_FUTURE_INIT |
    IntrinsicKind_FUTURE_IS_COMPLETE |
    IntrinsicKind_FUTURE_WAIT |
    IntrinsicKind_FUTURE_NOTIFYALL |
    IntrinsicKind_IS_THREAD_OBJECT_INITED |
    IntrinsicKind_GET_THREAD_OBJECT |
    IntrinsicKind_SET_THREAD_OBJECT |
    IntrinsicKind_OVERFLOW_CHECKED_ADD |
    IntrinsicKind_OVERFLOW_CHECKED_SUB |
    IntrinsicKind_OVERFLOW_CHECKED_MUL |
    IntrinsicKind_OVERFLOW_CHECKED_DIV |
    IntrinsicKind_OVERFLOW_CHECKED_MOD |
    IntrinsicKind_OVERFLOW_CHECKED_POW |
    IntrinsicKind_OVERFLOW_CHECKED_INC |
    IntrinsicKind_OVERFLOW_CHECKED_DEC |
    IntrinsicKind_OVERFLOW_CHECKED_NEG |
    IntrinsicKind_OVERFLOW_THROWING_ADD |
    IntrinsicKind_OVERFLOW_THROWING_SUB |
    IntrinsicKind_OVERFLOW_THROWING_MUL |
    IntrinsicKind_OVERFLOW_THROWING_DIV |
    IntrinsicKind_OVERFLOW_THROWING_MOD |
    IntrinsicKind_OVERFLOW_THROWING_POW |
    IntrinsicKind_OVERFLOW_THROWING_INC |
    IntrinsicKind_OVERFLOW_THROWING_DEC |
    IntrinsicKind_OVERFLOW_THROWING_NEG |
    IntrinsicKind_OVERFLOW_SATURATING_ADD |
    IntrinsicKind_OVERFLOW_SATURATING_SUB |
    IntrinsicKind_OVERFLOW_SATURATING_MUL |
    IntrinsicKind_OVERFLOW_SATURATING_DIV |
    IntrinsicKind_OVERFLOW_SATURATING_MOD |
    IntrinsicKind_OVERFLOW_SATURATING_POW |
    IntrinsicKind_OVERFLOW_SATURATING_INC |
    IntrinsicKind_OVERFLOW_SATURATING_DEC |
    IntrinsicKind_OVERFLOW_SATURATING_NEG |
    IntrinsicKind_OVERFLOW_WRAPPING_ADD |
    IntrinsicKind_OVERFLOW_WRAPPING_SUB |
    IntrinsicKind_OVERFLOW_WRAPPING_MUL |
    IntrinsicKind_OVERFLOW_WRAPPING_DIV |
    IntrinsicKind_OVERFLOW_WRAPPING_MOD |
    IntrinsicKind_OVERFLOW_WRAPPING_POW |
    IntrinsicKind_OVERFLOW_WRAPPING_INC |
    IntrinsicKind_OVERFLOW_WRAPPING_DEC |
    IntrinsicKind_OVERFLOW_WRAPPING_NEG |
    IntrinsicKind_VECTOR_COMPARE_32 |
    IntrinsicKind_VECTOR_INDEX_BYTE_32 |
    IntrinsicKind_CJ_CORE_CAN_USE_SIMD |
    IntrinsicKind_CJ_TLS_DYN_SET_SESSION_CALLBACK |
    IntrinsicKind_CJ_TLS_DYN_SSL_INIT |
    IntrinsicKind_REFLECTION_INTRINSIC_START_FLAG |
    IntrinsicKind_IS_INTERFACE |
    IntrinsicKind_IS_CLASS |
    IntrinsicKind_IS_PRIMITIVE |
    IntrinsicKind_IS_STRUCT |
    IntrinsicKind_IS_GENERIC |
    IntrinsicKind_GET_OR_CREATE_TYPEINFO_FOR_REFLECT |
    IntrinsicKind_GET_TYPETEMPLATE |
    IntrinsicKind_CHECK_METHOD_ACTUAL_ARGS |
    IntrinsicKind_METHOD_ENTRYPOINT_IS_NULL |
    IntrinsicKind_IS_RELECT_UNSUPPORTED_TYPE |
    IntrinsicKind_GET_TYPE_FOR_ANY |
    IntrinsicKind_GET_TYPE_BY_MANGLED_NAME |
    IntrinsicKind_GET_TYPE_NAME |
    IntrinsicKind_GET_TYPE_BY_QUALIFIED_NAME |
    IntrinsicKind_GET_TYPE_QUALIFIED_NAME_LENGTH |
    IntrinsicKind_GET_TYPE_QUALIFIED_NAME |
    IntrinsicKind_GET_NUM_OF_INTERFACE |
    IntrinsicKind_GET_INTERFACE |
    IntrinsicKind_IS_SUBTYPE |
    IntrinsicKind_GET_TYPE_INFO_MODIFIER |
    IntrinsicKind_GET_TYPE_INFO_ANNOTATIONS |
    IntrinsicKind_GET_OBJ_CLASS |
    IntrinsicKind_GET_SUPER_TYPE_INFO |
    IntrinsicKind_GET_NUM_OF_INSTANCE_METHOD_INFOS |
    IntrinsicKind_GET_INSTANCE_METHOD_INFO |
    IntrinsicKind_GET_NUM_OF_STATIC_METHOD_INFOS |
    IntrinsicKind_GET_STATIC_METHOD_INFO |
    IntrinsicKind_GET_METHOD_NAME |
    IntrinsicKind_GET_METHOD_RETURN_TYPE |
    IntrinsicKind_GET_METHOD_MODIFIER |
    IntrinsicKind_GET_METHOD_ANNOTATIONS |
    IntrinsicKind_APPLY_CJ_METHOD |
    IntrinsicKind_APPLY_CJ_STATIC_METHOD |
    IntrinsicKind_APPLY_CJ_GENERIC_METHOD |
    IntrinsicKind_APPLY_CJ_GENERIC_STATIC_METHOD |
    IntrinsicKind_GET_NUM_OF_ACTUAL_PARAMETERS |
    IntrinsicKind_GET_NUM_OF_GENERIC_PARAMETERS |
    IntrinsicKind_GET_ACTUAL_PARAMETER_INFO |
    IntrinsicKind_GET_GENERIC_PARAMETER_INFO |
    IntrinsicKind_GET_NUM_OF_INSTANCE_FIELD_INFOS |
    IntrinsicKind_GET_INSTANCE_FIELD_INFO |
    IntrinsicKind_GET_NUM_OF_STATIC_FIELD_INFOS |
    IntrinsicKind_GET_STATIC_FIELD_INFO |
    IntrinsicKind_GET_STATIC_FIELD_NAME |
    IntrinsicKind_GET_STATIC_FIELD_TYPE |
    IntrinsicKind_GET_STATIC_FIELD_ANNOTATIONS |
    IntrinsicKind_GET_FIELD_NAME |
    IntrinsicKind_GET_FIELD_TYPE |
    IntrinsicKind_GET_FIELD_ANNOTATIONS |
    IntrinsicKind_GET_FIELD_MODIFIER |
    IntrinsicKind_GET_STATIC_FIELD_MODIFIER |
    IntrinsicKind_GET_FIELD_VALUE |
    IntrinsicKind_SET_FIELD_VALUE |
    IntrinsicKind_GET_STATIC_FIELD_VALUE |
    IntrinsicKind_SET_STATIC_FIELD_VALUE |
    IntrinsicKind_GET_FIELD_DECLARING_TYPE |
    IntrinsicKind_GET_PARAMETER_INDEX |
    IntrinsicKind_GET_PARAMETER_NAME |
    IntrinsicKind_GET_PARAMETER_TYPE |
    IntrinsicKind_GET_PARAMETER_ANNOTATIONS |
    IntrinsicKind_GET_RELATED_PACKAGE_INF |
    IntrinsicKind_GET_PACKAGE_NAME |
    IntrinsicKind_GET_PACKAGE_NUM_OF_TYPE_INFOS |
    IntrinsicKind_GET_PACKAGE_TYPE_INFO |
    IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_METHODS |
    IntrinsicKind_GET_PACKAGE_GLOBAL_METHOD_INFO |
    IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_FIELD_INFOS |
    IntrinsicKind_GET_PACKAGE_GLOBAL_FIELD_INFO |
    IntrinsicKind_LOAD_PACKAGE |
    IntrinsicKind_GET_PACKAGE_BY_QUALIFIEDNAME |
    IntrinsicKind_GET_PACKAGE_VERSION |
    IntrinsicKind_GET_SUB_PACKAGES |
    IntrinsicKind_REFLECTION_INTRINSIC_END_FLAG |
    IntrinsicKind_SLEEP |
    IntrinsicKind_SOURCE_FILE |
    IntrinsicKind_SOURCE_LINE |
    IntrinsicKind_IDENTITY_HASHCODE |
    IntrinsicKind_IDENTITY_HASHCODE_FOR_ARRAY |
    IntrinsicKind_ATOMIC_LOAD |
    IntrinsicKind_ATOMIC_STORE |
    IntrinsicKind_ATOMIC_SWAP |
    IntrinsicKind_ATOMIC_COMPARE_AND_SWAP |
    IntrinsicKind_ATOMIC_FETCH_ADD |
    IntrinsicKind_ATOMIC_FETCH_SUB |
    IntrinsicKind_ATOMIC_FETCH_AND |
    IntrinsicKind_ATOMIC_FETCH_OR |
    IntrinsicKind_ATOMIC_FETCH_XOR |
    IntrinsicKind_MUTEX_INIT |
    IntrinsicKind_CJ_MUTEX_LOCK |
    IntrinsicKind_MUTEX_TRY_LOCK |
    IntrinsicKind_MUTEX_CHECK_STATUS |
    IntrinsicKind_MUTEX_UNLOCK |
    IntrinsicKind_WAITQUEUE_INIT |
    IntrinsicKind_MONITOR_INIT |
    IntrinsicKind_MOITIOR_WAIT |
    IntrinsicKind_MOITIOR_NOTIFY |
    IntrinsicKind_MOITIOR_NOTIFY_ALL |
    IntrinsicKind_MULTICONDITION_WAIT |
    IntrinsicKind_MULTICONDITION_NOTIFY |
    IntrinsicKind_MULTICONDITION_NOTIFY_ALL |
    IntrinsicKind_CROSS_ACCESS_BARRIER |
    IntrinsicKind_CREATE_EXPORT_HANDLE |
    IntrinsicKind_GET_EXPORTED_REF |
    IntrinsicKind_REMOVE_EXPORTED_REF |
    IntrinsicKind_FFI_CJ_AST_LEX |
    IntrinsicKind_FFI_CJ_AST_PARSEEXPR |
    IntrinsicKind_FFI_CJ_AST_PARSEDECL |
    IntrinsicKind_FFI_CJ_AST_PARSE_PROPMEMBERDECL |
    IntrinsicKind_FFI_CJ_AST_PARSE_PRICONSTRUCTOR |
    IntrinsicKind_FFI_CJ_AST_PARSE_PATTERN |
    IntrinsicKind_FFI_CJ_AST_PARSE_TYPE |
    IntrinsicKind_FFI_CJ_AST_PARSETOPLEVEL |
    IntrinsicKind_FFI_CJ_AST_DIAGREPORT |
    IntrinsicKind_FFI_CJ_PARENT_CONTEXT |
    IntrinsicKind_FFI_CJ_MACRO_ITEM_INFO |
    IntrinsicKind_FFI_CJ_GET_CHILD_MESSAGES |
    IntrinsicKind_FFI_CJ_CHECK_ADD_SPACE |
    IntrinsicKind_CG_UNSAFE_BEGIN |
    IntrinsicKind_CG_UNSAFE_END |
    IntrinsicKind_STRLEN |
    IntrinsicKind_MEMCPY_S |
    IntrinsicKind_MEMSET_S |
    IntrinsicKind_FREE |
    IntrinsicKind_MALLOC |
    IntrinsicKind_STRCMP |
    IntrinsicKind_MEMCMP |
    IntrinsicKind_STRNCMP |
    IntrinsicKind_STRCASECMP |
    IntrinsicKind_ATOMIC_INT8_LOAD |
    IntrinsicKind_ATOMIC_INT8_STORE |
    IntrinsicKind_ATOMIC_INT8_SWAP |
    IntrinsicKind_ATOMIC_INT8_CAS |
    IntrinsicKind_ATOMIC_INT8_FETCH_ADD |
    IntrinsicKind_ATOMIC_INT8_FETCH_SUB |
    IntrinsicKind_ATOMIC_INT8_FETCH_AND |
    IntrinsicKind_ATOMIC_INT8_FETCH_OR |
    IntrinsicKind_ATOMIC_INT8_FETCH_XOR |
    IntrinsicKind_ATOMIC_INT16_LOAD |
    IntrinsicKind_ATOMIC_INT16_STORE |
    IntrinsicKind_ATOMIC_INT16_SWAP |
    IntrinsicKind_ATOMIC_INT16_CAS |
    IntrinsicKind_ATOMIC_INT16_FETCH_ADD |
    IntrinsicKind_ATOMIC_INT16_FETCH_SUB |
    IntrinsicKind_ATOMIC_INT16_FETCH_AND |
    IntrinsicKind_ATOMIC_INT16_FETCH_OR |
    IntrinsicKind_ATOMIC_INT16_FETCH_XOR |
    IntrinsicKind_ATOMIC_INT32_LOAD |
    IntrinsicKind_ATOMIC_INT32_STORE |
    IntrinsicKind_ATOMIC_INT32_SWAP |
    IntrinsicKind_ATOMIC_INT32_CAS |
    IntrinsicKind_ATOMIC_INT32_FETCH_ADD |
    IntrinsicKind_ATOMIC_INT32_FETCH_SUB |
    IntrinsicKind_ATOMIC_INT32_FETCH_AND |
    IntrinsicKind_ATOMIC_INT32_FETCH_OR |
    IntrinsicKind_ATOMIC_INT32_FETCH_XOR |
    IntrinsicKind_ATOMIC_INT64_LOAD |
    IntrinsicKind_ATOMIC_INT64_STORE |
    IntrinsicKind_ATOMIC_INT64_SWAP |
    IntrinsicKind_ATOMIC_INT64_CAS |
    IntrinsicKind_ATOMIC_INT64_FETCH_ADD |
    IntrinsicKind_ATOMIC_INT64_FETCH_SUB |
    IntrinsicKind_ATOMIC_INT64_FETCH_AND |
    IntrinsicKind_ATOMIC_INT64_FETCH_OR |
    IntrinsicKind_ATOMIC_INT64_FETCH_XOR |
    IntrinsicKind_ATOMIC_UINT8_LOAD |
    IntrinsicKind_ATOMIC_UINT8_STORE |
    IntrinsicKind_ATOMIC_UINT8_SWAP |
    IntrinsicKind_ATOMIC_UINT8_CAS |
    IntrinsicKind_ATOMIC_UINT8_FETCH_ADD |
    IntrinsicKind_ATOMIC_UINT8_FETCH_SUB |
    IntrinsicKind_ATOMIC_UINT8_FETCH_AND |
    IntrinsicKind_ATOMIC_UINT8_FETCH_OR |
    IntrinsicKind_ATOMIC_UINT8_FETCH_XOR |
    IntrinsicKind_ATOMIC_UINT16_LOAD |
    IntrinsicKind_ATOMIC_UINT16_STORE |
    IntrinsicKind_ATOMIC_UINT16_SWAP |
    IntrinsicKind_ATOMIC_UINT16_CAS |
    IntrinsicKind_ATOMIC_UINT16_FETCH_ADD |
    IntrinsicKind_ATOMIC_UINT16_FETCH_SUB |
    IntrinsicKind_ATOMIC_UINT16_FETCH_AND |
    IntrinsicKind_ATOMIC_UINT16_FETCH_OR |
    IntrinsicKind_ATOMIC_UINT16_FETCH_XOR |
    IntrinsicKind_ATOMIC_UINT32_LOAD |
    IntrinsicKind_ATOMIC_UINT32_STORE |
    IntrinsicKind_ATOMIC_UINT32_SWAP |
    IntrinsicKind_ATOMIC_UINT32_CAS |
    IntrinsicKind_ATOMIC_UINT32_FETCH_ADD |
    IntrinsicKind_ATOMIC_UINT32_FETCH_SUB |
    IntrinsicKind_ATOMIC_UINT32_FETCH_AND |
    IntrinsicKind_ATOMIC_UINT32_FETCH_OR |
    IntrinsicKind_ATOMIC_UINT32_FETCH_XOR |
    IntrinsicKind_ATOMIC_UINT64_LOAD |
    IntrinsicKind_ATOMIC_UINT64_STORE |
    IntrinsicKind_ATOMIC_UINT64_SWAP |
    IntrinsicKind_ATOMIC_UINT64_CAS |
    IntrinsicKind_ATOMIC_UINT64_FETCH_ADD |
    IntrinsicKind_ATOMIC_UINT64_FETCH_SUB |
    IntrinsicKind_ATOMIC_UINT64_FETCH_AND |
    IntrinsicKind_ATOMIC_UINT64_FETCH_OR |
    IntrinsicKind_ATOMIC_UINT64_FETCH_XOR |
    IntrinsicKind_ATOMIC_BOOL_LOAD |
    IntrinsicKind_ATOMIC_BOOL_STORE |
    IntrinsicKind_ATOMIC_BOOL_SWAP |
    IntrinsicKind_ATOMIC_BOOL_CAS |
    IntrinsicKind_ATOMIC_REFERENCEBASE_LOAD |
    IntrinsicKind_ATOMIC_REFERENCEBASE_STORE |
    IntrinsicKind_ATOMIC_REFERENCEBASE_SWAP |
    IntrinsicKind_ATOMIC_REFERENCEBASE_CAS |
    IntrinsicKind_ATOMIC_OPTIONREFERENCE_LOAD |
    IntrinsicKind_ATOMIC_OPTIONREFERENCE_STORE |
    IntrinsicKind_ATOMIC_OPTIONREFERENCE_SWAP |
    IntrinsicKind_ATOMIC_OPTIONREFERENCE_CAS |
    IntrinsicKind_BEGIN_CATCH |
    IntrinsicKind_ABS |
    IntrinsicKind_FABS |
    IntrinsicKind_FLOOR |
    IntrinsicKind_CEIL |
    IntrinsicKind_TRUNC |
    IntrinsicKind_SIN |
    IntrinsicKind_COS |
    IntrinsicKind_EXP |
    IntrinsicKind_EXP2 |
    IntrinsicKind_LOG |
    IntrinsicKind_LOG2 |
    IntrinsicKind_LOG10 |
    IntrinsicKind_SQRT |
    IntrinsicKind_ROUND |
    IntrinsicKind_POW |
    IntrinsicKind_POWI |
    IntrinsicKind_BIT_CAST |
    IntrinsicKind_PREINITIALIZE |
    IntrinsicKind_OBJECT_AS |
    IntrinsicKind_IS_NULL |
    IntrinsicKind_GET_TYPE_FOR_TYPE_PARAMETER |
    IntrinsicKind_IS_SUBTYPE_TYPES
}

func EnumValuesPackageFormat_IntrinsicKind(e: UInt16) : PackageFormat_IntrinsicKind {
    var values: Array<PackageFormat_IntrinsicKind> = [
        PackageFormat_IntrinsicKind.IntrinsicKind_NOT_INTRINSIC,
        PackageFormat_IntrinsicKind.IntrinsicKind_NOT_IMPLEMENTED,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_SIZE_OF,
        PackageFormat_IntrinsicKind.IntrinsicKind_ALIGN_OF,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_ACQUIRE_RAW_DATA,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_RELEASE_RAW_DATA,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_BUILT_IN_COPY_TO,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SET,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET_UNCHECKED,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET_REF_UNCHECKED,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SET_UNCHECKED,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_CLONE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_RAWARRAY,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_START,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_GET_ELEMENT,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_GET_ELEMENT_UNCHECKED,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SET_ELEMENT,
        PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SET_ELEMENT_UNCHECKED,
        PackageFormat_IntrinsicKind.IntrinsicKind_FILL_IN_STACK_TRACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_DECODE_STACK_TRACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_CURRENT_THREAD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_ALL_THREADS_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_CHR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ORD,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_GET_POINTER_ADDRESS,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_INIT0,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_INIT1,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_READ,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_WRITE,
        PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_CSTRING_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_CSTRING_CONVERT_CSTR_TO_PTR,
        PackageFormat_IntrinsicKind.IntrinsicKind_INOUT_PARAM,
        PackageFormat_IntrinsicKind.IntrinsicKind_REGISTER_WATCHED_OBJECT,
        PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_REFEQ,
        PackageFormat_IntrinsicKind.IntrinsicKind_RAW_ARRAY_REFEQ,
        PackageFormat_IntrinsicKind.IntrinsicKind_FUNC_REFEQ,
        PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_ZERO_VALUE,
        PackageFormat_IntrinsicKind.IntrinsicKind_INVOKE_GC,
        PackageFormat_IntrinsicKind.IntrinsicKind_SET_GC_THRESHOLD,
        PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_CJ_HEAP_DATA,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_COUNT,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_TIME_US,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_FREED_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_START_CJ_CPU_PROFILING,
        PackageFormat_IntrinsicKind.IntrinsicKind_STOP_CJ_CPU_PROFILING,
        PackageFormat_IntrinsicKind.IntrinsicKind_BLACK_BOX,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_MAX_HEAP_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_ALLOCATE_HEAP_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_REAL_HEAP_SIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_THREAD_NUMBER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_BLOCKING_THREAD_NUMBER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NATIVE_THREAD_NUMBER,
        PackageFormat_IntrinsicKind.IntrinsicKind_VARRAY_SET,
        PackageFormat_IntrinsicKind.IntrinsicKind_VARRAY_GET,
        PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_IS_COMPLETE,
        PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_WAIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_NOTIFYALL,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_THREAD_OBJECT_INITED,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_THREAD_OBJECT,
        PackageFormat_IntrinsicKind.IntrinsicKind_SET_THREAD_OBJECT,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_MUL,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_DIV,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_MOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_POW,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_INC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_DEC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_NEG,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_MUL,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_DIV,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_MOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_POW,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_INC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_DEC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_NEG,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_MUL,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_DIV,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_MOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_POW,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_INC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_DEC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_NEG,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_MUL,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_DIV,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_MOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_POW,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_INC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_DEC,
        PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_NEG,
        PackageFormat_IntrinsicKind.IntrinsicKind_VECTOR_COMPARE_32,
        PackageFormat_IntrinsicKind.IntrinsicKind_VECTOR_INDEX_BYTE_32,
        PackageFormat_IntrinsicKind.IntrinsicKind_CJ_CORE_CAN_USE_SIMD,
        PackageFormat_IntrinsicKind.IntrinsicKind_CJ_TLS_DYN_SET_SESSION_CALLBACK,
        PackageFormat_IntrinsicKind.IntrinsicKind_CJ_TLS_DYN_SSL_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_REFLECTION_INTRINSIC_START_FLAG,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_INTERFACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_CLASS,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_PRIMITIVE,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_STRUCT,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_GENERIC,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_OR_CREATE_TYPEINFO_FOR_REFLECT,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPETEMPLATE,
        PackageFormat_IntrinsicKind.IntrinsicKind_CHECK_METHOD_ACTUAL_ARGS,
        PackageFormat_IntrinsicKind.IntrinsicKind_METHOD_ENTRYPOINT_IS_NULL,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_RELECT_UNSUPPORTED_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_FOR_ANY,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_BY_MANGLED_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_BY_QUALIFIED_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_QUALIFIED_NAME_LENGTH,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_QUALIFIED_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INTERFACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_INTERFACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_SUBTYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_INFO_MODIFIER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_INFO_ANNOTATIONS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_OBJ_CLASS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_SUPER_TYPE_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INSTANCE_METHOD_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_INSTANCE_METHOD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_STATIC_METHOD_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_METHOD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_RETURN_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_MODIFIER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_ANNOTATIONS,
        PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_METHOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_STATIC_METHOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_GENERIC_METHOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_GENERIC_STATIC_METHOD,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_ACTUAL_PARAMETERS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_GENERIC_PARAMETERS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_ACTUAL_PARAMETER_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_GENERIC_PARAMETER_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INSTANCE_FIELD_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_INSTANCE_FIELD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_STATIC_FIELD_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_ANNOTATIONS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_ANNOTATIONS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_MODIFIER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_MODIFIER,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_VALUE,
        PackageFormat_IntrinsicKind.IntrinsicKind_SET_FIELD_VALUE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_VALUE,
        PackageFormat_IntrinsicKind.IntrinsicKind_SET_STATIC_FIELD_VALUE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_DECLARING_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_INDEX,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_ANNOTATIONS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_RELATED_PACKAGE_INF,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_TYPE_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_TYPE_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_METHODS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_GLOBAL_METHOD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_FIELD_INFOS,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_GLOBAL_FIELD_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_LOAD_PACKAGE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_BY_QUALIFIEDNAME,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_VERSION,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_SUB_PACKAGES,
        PackageFormat_IntrinsicKind.IntrinsicKind_REFLECTION_INTRINSIC_END_FLAG,
        PackageFormat_IntrinsicKind.IntrinsicKind_SLEEP,
        PackageFormat_IntrinsicKind.IntrinsicKind_SOURCE_FILE,
        PackageFormat_IntrinsicKind.IntrinsicKind_SOURCE_LINE,
        PackageFormat_IntrinsicKind.IntrinsicKind_IDENTITY_HASHCODE,
        PackageFormat_IntrinsicKind.IntrinsicKind_IDENTITY_HASHCODE_FOR_ARRAY,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_COMPARE_AND_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_CJ_MUTEX_LOCK,
        PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_TRY_LOCK,
        PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_CHECK_STATUS,
        PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_UNLOCK,
        PackageFormat_IntrinsicKind.IntrinsicKind_WAITQUEUE_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_MONITOR_INIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_WAIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_NOTIFY,
        PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_NOTIFY_ALL,
        PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_WAIT,
        PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_NOTIFY,
        PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_NOTIFY_ALL,
        PackageFormat_IntrinsicKind.IntrinsicKind_CROSS_ACCESS_BARRIER,
        PackageFormat_IntrinsicKind.IntrinsicKind_CREATE_EXPORT_HANDLE,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_EXPORTED_REF,
        PackageFormat_IntrinsicKind.IntrinsicKind_REMOVE_EXPORTED_REF,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_LEX,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSEEXPR,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSEDECL,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PROPMEMBERDECL,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PRICONSTRUCTOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PATTERN,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_TYPE,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSETOPLEVEL,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_DIAGREPORT,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_PARENT_CONTEXT,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_MACRO_ITEM_INFO,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_GET_CHILD_MESSAGES,
        PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_CHECK_ADD_SPACE,
        PackageFormat_IntrinsicKind.IntrinsicKind_CG_UNSAFE_BEGIN,
        PackageFormat_IntrinsicKind.IntrinsicKind_CG_UNSAFE_END,
        PackageFormat_IntrinsicKind.IntrinsicKind_STRLEN,
        PackageFormat_IntrinsicKind.IntrinsicKind_MEMCPY_S,
        PackageFormat_IntrinsicKind.IntrinsicKind_MEMSET_S,
        PackageFormat_IntrinsicKind.IntrinsicKind_FREE,
        PackageFormat_IntrinsicKind.IntrinsicKind_MALLOC,
        PackageFormat_IntrinsicKind.IntrinsicKind_STRCMP,
        PackageFormat_IntrinsicKind.IntrinsicKind_MEMCMP,
        PackageFormat_IntrinsicKind.IntrinsicKind_STRNCMP,
        PackageFormat_IntrinsicKind.IntrinsicKind_STRCASECMP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_ADD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_SUB,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_AND,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_OR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_XOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_LOAD,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_STORE,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_SWAP,
        PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_CAS,
        PackageFormat_IntrinsicKind.IntrinsicKind_BEGIN_CATCH,
        PackageFormat_IntrinsicKind.IntrinsicKind_ABS,
        PackageFormat_IntrinsicKind.IntrinsicKind_FABS,
        PackageFormat_IntrinsicKind.IntrinsicKind_FLOOR,
        PackageFormat_IntrinsicKind.IntrinsicKind_CEIL,
        PackageFormat_IntrinsicKind.IntrinsicKind_TRUNC,
        PackageFormat_IntrinsicKind.IntrinsicKind_SIN,
        PackageFormat_IntrinsicKind.IntrinsicKind_COS,
        PackageFormat_IntrinsicKind.IntrinsicKind_EXP,
        PackageFormat_IntrinsicKind.IntrinsicKind_EXP2,
        PackageFormat_IntrinsicKind.IntrinsicKind_LOG,
        PackageFormat_IntrinsicKind.IntrinsicKind_LOG2,
        PackageFormat_IntrinsicKind.IntrinsicKind_LOG10,
        PackageFormat_IntrinsicKind.IntrinsicKind_SQRT,
        PackageFormat_IntrinsicKind.IntrinsicKind_ROUND,
        PackageFormat_IntrinsicKind.IntrinsicKind_POW,
        PackageFormat_IntrinsicKind.IntrinsicKind_POWI,
        PackageFormat_IntrinsicKind.IntrinsicKind_BIT_CAST,
        PackageFormat_IntrinsicKind.IntrinsicKind_PREINITIALIZE,
        PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_AS,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_NULL,
        PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_FOR_TYPE_PARAMETER,
        PackageFormat_IntrinsicKind.IntrinsicKind_IS_SUBTYPE_TYPES
    ]
    return if (e < 345) { values[Int64(e)] } else { IntrinsicKind_NOT_INTRINSIC }
}

func EnumPackageFormat_IntrinsicKindValues(e: PackageFormat_IntrinsicKind) : UInt16 {
    return match (e) {
        case PackageFormat_IntrinsicKind.IntrinsicKind_NOT_INTRINSIC => 0
        case PackageFormat_IntrinsicKind.IntrinsicKind_NOT_IMPLEMENTED => 1
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_INIT => 2
        case PackageFormat_IntrinsicKind.IntrinsicKind_SIZE_OF => 3
        case PackageFormat_IntrinsicKind.IntrinsicKind_ALIGN_OF => 4
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_ACQUIRE_RAW_DATA => 5
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_RELEASE_RAW_DATA => 6
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_BUILT_IN_COPY_TO => 7
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET => 8
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SET => 9
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET_UNCHECKED => 10
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_GET_REF_UNCHECKED => 11
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SET_UNCHECKED => 12
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SIZE => 13
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_CLONE => 14
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_INIT => 15
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE => 16
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_RAWARRAY => 17
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_START => 18
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SIZE => 19
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_GET_ELEMENT => 20
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_GET_ELEMENT_UNCHECKED => 21
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SET_ELEMENT => 22
        case PackageFormat_IntrinsicKind.IntrinsicKind_ARRAY_SLICE_SET_ELEMENT_UNCHECKED => 23
        case PackageFormat_IntrinsicKind.IntrinsicKind_FILL_IN_STACK_TRACE => 24
        case PackageFormat_IntrinsicKind.IntrinsicKind_DECODE_STACK_TRACE => 25
        case PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_CURRENT_THREAD_INFO => 26
        case PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_ALL_THREADS_INFO => 27
        case PackageFormat_IntrinsicKind.IntrinsicKind_CHR => 28
        case PackageFormat_IntrinsicKind.IntrinsicKind_ORD => 29
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_GET_POINTER_ADDRESS => 30
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_INIT0 => 31
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_INIT1 => 32
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_READ => 33
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_WRITE => 34
        case PackageFormat_IntrinsicKind.IntrinsicKind_CPOINTER_ADD => 35
        case PackageFormat_IntrinsicKind.IntrinsicKind_CSTRING_INIT => 36
        case PackageFormat_IntrinsicKind.IntrinsicKind_CSTRING_CONVERT_CSTR_TO_PTR => 37
        case PackageFormat_IntrinsicKind.IntrinsicKind_INOUT_PARAM => 38
        case PackageFormat_IntrinsicKind.IntrinsicKind_REGISTER_WATCHED_OBJECT => 39
        case PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_REFEQ => 40
        case PackageFormat_IntrinsicKind.IntrinsicKind_RAW_ARRAY_REFEQ => 41
        case PackageFormat_IntrinsicKind.IntrinsicKind_FUNC_REFEQ => 42
        case PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_ZERO_VALUE => 43
        case PackageFormat_IntrinsicKind.IntrinsicKind_INVOKE_GC => 44
        case PackageFormat_IntrinsicKind.IntrinsicKind_SET_GC_THRESHOLD => 45
        case PackageFormat_IntrinsicKind.IntrinsicKind_DUMP_CJ_HEAP_DATA => 46
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_COUNT => 47
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_TIME_US => 48
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_GC_FREED_SIZE => 49
        case PackageFormat_IntrinsicKind.IntrinsicKind_START_CJ_CPU_PROFILING => 50
        case PackageFormat_IntrinsicKind.IntrinsicKind_STOP_CJ_CPU_PROFILING => 51
        case PackageFormat_IntrinsicKind.IntrinsicKind_BLACK_BOX => 52
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_MAX_HEAP_SIZE => 53
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_ALLOCATE_HEAP_SIZE => 54
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_REAL_HEAP_SIZE => 55
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_THREAD_NUMBER => 56
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_BLOCKING_THREAD_NUMBER => 57
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NATIVE_THREAD_NUMBER => 58
        case PackageFormat_IntrinsicKind.IntrinsicKind_VARRAY_SET => 59
        case PackageFormat_IntrinsicKind.IntrinsicKind_VARRAY_GET => 60
        case PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_INIT => 61
        case PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_IS_COMPLETE => 62
        case PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_WAIT => 63
        case PackageFormat_IntrinsicKind.IntrinsicKind_FUTURE_NOTIFYALL => 64
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_THREAD_OBJECT_INITED => 65
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_THREAD_OBJECT => 66
        case PackageFormat_IntrinsicKind.IntrinsicKind_SET_THREAD_OBJECT => 67
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_ADD => 68
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_SUB => 69
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_MUL => 70
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_DIV => 71
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_MOD => 72
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_POW => 73
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_INC => 74
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_DEC => 75
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_CHECKED_NEG => 76
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_ADD => 77
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_SUB => 78
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_MUL => 79
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_DIV => 80
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_MOD => 81
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_POW => 82
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_INC => 83
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_DEC => 84
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_THROWING_NEG => 85
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_ADD => 86
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_SUB => 87
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_MUL => 88
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_DIV => 89
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_MOD => 90
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_POW => 91
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_INC => 92
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_DEC => 93
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_SATURATING_NEG => 94
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_ADD => 95
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_SUB => 96
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_MUL => 97
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_DIV => 98
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_MOD => 99
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_POW => 100
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_INC => 101
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_DEC => 102
        case PackageFormat_IntrinsicKind.IntrinsicKind_OVERFLOW_WRAPPING_NEG => 103
        case PackageFormat_IntrinsicKind.IntrinsicKind_VECTOR_COMPARE_32 => 104
        case PackageFormat_IntrinsicKind.IntrinsicKind_VECTOR_INDEX_BYTE_32 => 105
        case PackageFormat_IntrinsicKind.IntrinsicKind_CJ_CORE_CAN_USE_SIMD => 106
        case PackageFormat_IntrinsicKind.IntrinsicKind_CJ_TLS_DYN_SET_SESSION_CALLBACK => 107
        case PackageFormat_IntrinsicKind.IntrinsicKind_CJ_TLS_DYN_SSL_INIT => 108
        case PackageFormat_IntrinsicKind.IntrinsicKind_REFLECTION_INTRINSIC_START_FLAG => 109
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_INTERFACE => 110
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_CLASS => 111
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_PRIMITIVE => 112
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_STRUCT => 113
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_GENERIC => 114
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_OR_CREATE_TYPEINFO_FOR_REFLECT => 115
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPETEMPLATE => 116
        case PackageFormat_IntrinsicKind.IntrinsicKind_CHECK_METHOD_ACTUAL_ARGS => 117
        case PackageFormat_IntrinsicKind.IntrinsicKind_METHOD_ENTRYPOINT_IS_NULL => 118
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_RELECT_UNSUPPORTED_TYPE => 119
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_FOR_ANY => 120
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_BY_MANGLED_NAME => 121
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_NAME => 122
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_BY_QUALIFIED_NAME => 123
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_QUALIFIED_NAME_LENGTH => 124
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_QUALIFIED_NAME => 125
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INTERFACE => 126
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_INTERFACE => 127
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_SUBTYPE => 128
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_INFO_MODIFIER => 129
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_INFO_ANNOTATIONS => 130
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_OBJ_CLASS => 131
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_SUPER_TYPE_INFO => 132
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INSTANCE_METHOD_INFOS => 133
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_INSTANCE_METHOD_INFO => 134
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_STATIC_METHOD_INFOS => 135
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_METHOD_INFO => 136
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_NAME => 137
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_RETURN_TYPE => 138
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_MODIFIER => 139
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_METHOD_ANNOTATIONS => 140
        case PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_METHOD => 141
        case PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_STATIC_METHOD => 142
        case PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_GENERIC_METHOD => 143
        case PackageFormat_IntrinsicKind.IntrinsicKind_APPLY_CJ_GENERIC_STATIC_METHOD => 144
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_ACTUAL_PARAMETERS => 145
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_GENERIC_PARAMETERS => 146
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_ACTUAL_PARAMETER_INFO => 147
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_GENERIC_PARAMETER_INFO => 148
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_INSTANCE_FIELD_INFOS => 149
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_INSTANCE_FIELD_INFO => 150
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_NUM_OF_STATIC_FIELD_INFOS => 151
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_INFO => 152
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_NAME => 153
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_TYPE => 154
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_ANNOTATIONS => 155
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_NAME => 156
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_TYPE => 157
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_ANNOTATIONS => 158
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_MODIFIER => 159
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_MODIFIER => 160
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_VALUE => 161
        case PackageFormat_IntrinsicKind.IntrinsicKind_SET_FIELD_VALUE => 162
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_STATIC_FIELD_VALUE => 163
        case PackageFormat_IntrinsicKind.IntrinsicKind_SET_STATIC_FIELD_VALUE => 164
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_FIELD_DECLARING_TYPE => 165
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_INDEX => 166
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_NAME => 167
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_TYPE => 168
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PARAMETER_ANNOTATIONS => 169
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_RELATED_PACKAGE_INF => 170
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NAME => 171
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_TYPE_INFOS => 172
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_TYPE_INFO => 173
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_METHODS => 174
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_GLOBAL_METHOD_INFO => 175
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_NUM_OF_GLOBAL_FIELD_INFOS => 176
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_GLOBAL_FIELD_INFO => 177
        case PackageFormat_IntrinsicKind.IntrinsicKind_LOAD_PACKAGE => 178
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_BY_QUALIFIEDNAME => 179
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_PACKAGE_VERSION => 180
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_SUB_PACKAGES => 181
        case PackageFormat_IntrinsicKind.IntrinsicKind_REFLECTION_INTRINSIC_END_FLAG => 182
        case PackageFormat_IntrinsicKind.IntrinsicKind_SLEEP => 183
        case PackageFormat_IntrinsicKind.IntrinsicKind_SOURCE_FILE => 184
        case PackageFormat_IntrinsicKind.IntrinsicKind_SOURCE_LINE => 185
        case PackageFormat_IntrinsicKind.IntrinsicKind_IDENTITY_HASHCODE => 186
        case PackageFormat_IntrinsicKind.IntrinsicKind_IDENTITY_HASHCODE_FOR_ARRAY => 187
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_LOAD => 188
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_STORE => 189
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_SWAP => 190
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_COMPARE_AND_SWAP => 191
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_ADD => 192
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_SUB => 193
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_AND => 194
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_OR => 195
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_FETCH_XOR => 196
        case PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_INIT => 197
        case PackageFormat_IntrinsicKind.IntrinsicKind_CJ_MUTEX_LOCK => 198
        case PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_TRY_LOCK => 199
        case PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_CHECK_STATUS => 200
        case PackageFormat_IntrinsicKind.IntrinsicKind_MUTEX_UNLOCK => 201
        case PackageFormat_IntrinsicKind.IntrinsicKind_WAITQUEUE_INIT => 202
        case PackageFormat_IntrinsicKind.IntrinsicKind_MONITOR_INIT => 203
        case PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_WAIT => 204
        case PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_NOTIFY => 205
        case PackageFormat_IntrinsicKind.IntrinsicKind_MOITIOR_NOTIFY_ALL => 206
        case PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_WAIT => 207
        case PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_NOTIFY => 208
        case PackageFormat_IntrinsicKind.IntrinsicKind_MULTICONDITION_NOTIFY_ALL => 209
        case PackageFormat_IntrinsicKind.IntrinsicKind_CROSS_ACCESS_BARRIER => 210
        case PackageFormat_IntrinsicKind.IntrinsicKind_CREATE_EXPORT_HANDLE => 211
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_EXPORTED_REF => 212
        case PackageFormat_IntrinsicKind.IntrinsicKind_REMOVE_EXPORTED_REF => 213
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_LEX => 214
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSEEXPR => 215
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSEDECL => 216
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PROPMEMBERDECL => 217
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PRICONSTRUCTOR => 218
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_PATTERN => 219
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSE_TYPE => 220
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_PARSETOPLEVEL => 221
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_AST_DIAGREPORT => 222
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_PARENT_CONTEXT => 223
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_MACRO_ITEM_INFO => 224
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_GET_CHILD_MESSAGES => 225
        case PackageFormat_IntrinsicKind.IntrinsicKind_FFI_CJ_CHECK_ADD_SPACE => 226
        case PackageFormat_IntrinsicKind.IntrinsicKind_CG_UNSAFE_BEGIN => 227
        case PackageFormat_IntrinsicKind.IntrinsicKind_CG_UNSAFE_END => 228
        case PackageFormat_IntrinsicKind.IntrinsicKind_STRLEN => 229
        case PackageFormat_IntrinsicKind.IntrinsicKind_MEMCPY_S => 230
        case PackageFormat_IntrinsicKind.IntrinsicKind_MEMSET_S => 231
        case PackageFormat_IntrinsicKind.IntrinsicKind_FREE => 232
        case PackageFormat_IntrinsicKind.IntrinsicKind_MALLOC => 233
        case PackageFormat_IntrinsicKind.IntrinsicKind_STRCMP => 234
        case PackageFormat_IntrinsicKind.IntrinsicKind_MEMCMP => 235
        case PackageFormat_IntrinsicKind.IntrinsicKind_STRNCMP => 236
        case PackageFormat_IntrinsicKind.IntrinsicKind_STRCASECMP => 237
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_LOAD => 238
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_STORE => 239
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_SWAP => 240
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_CAS => 241
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_ADD => 242
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_SUB => 243
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_AND => 244
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_OR => 245
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT8_FETCH_XOR => 246
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_LOAD => 247
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_STORE => 248
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_SWAP => 249
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_CAS => 250
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_ADD => 251
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_SUB => 252
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_AND => 253
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_OR => 254
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT16_FETCH_XOR => 255
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_LOAD => 256
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_STORE => 257
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_SWAP => 258
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_CAS => 259
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_ADD => 260
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_SUB => 261
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_AND => 262
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_OR => 263
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT32_FETCH_XOR => 264
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_LOAD => 265
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_STORE => 266
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_SWAP => 267
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_CAS => 268
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_ADD => 269
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_SUB => 270
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_AND => 271
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_OR => 272
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_INT64_FETCH_XOR => 273
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_LOAD => 274
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_STORE => 275
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_SWAP => 276
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_CAS => 277
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_ADD => 278
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_SUB => 279
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_AND => 280
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_OR => 281
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT8_FETCH_XOR => 282
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_LOAD => 283
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_STORE => 284
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_SWAP => 285
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_CAS => 286
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_ADD => 287
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_SUB => 288
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_AND => 289
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_OR => 290
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT16_FETCH_XOR => 291
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_LOAD => 292
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_STORE => 293
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_SWAP => 294
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_CAS => 295
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_ADD => 296
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_SUB => 297
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_AND => 298
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_OR => 299
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT32_FETCH_XOR => 300
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_LOAD => 301
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_STORE => 302
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_SWAP => 303
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_CAS => 304
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_ADD => 305
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_SUB => 306
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_AND => 307
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_OR => 308
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_UINT64_FETCH_XOR => 309
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_LOAD => 310
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_STORE => 311
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_SWAP => 312
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_BOOL_CAS => 313
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_LOAD => 314
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_STORE => 315
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_SWAP => 316
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_REFERENCEBASE_CAS => 317
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_LOAD => 318
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_STORE => 319
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_SWAP => 320
        case PackageFormat_IntrinsicKind.IntrinsicKind_ATOMIC_OPTIONREFERENCE_CAS => 321
        case PackageFormat_IntrinsicKind.IntrinsicKind_BEGIN_CATCH => 322
        case PackageFormat_IntrinsicKind.IntrinsicKind_ABS => 323
        case PackageFormat_IntrinsicKind.IntrinsicKind_FABS => 324
        case PackageFormat_IntrinsicKind.IntrinsicKind_FLOOR => 325
        case PackageFormat_IntrinsicKind.IntrinsicKind_CEIL => 326
        case PackageFormat_IntrinsicKind.IntrinsicKind_TRUNC => 327
        case PackageFormat_IntrinsicKind.IntrinsicKind_SIN => 328
        case PackageFormat_IntrinsicKind.IntrinsicKind_COS => 329
        case PackageFormat_IntrinsicKind.IntrinsicKind_EXP => 330
        case PackageFormat_IntrinsicKind.IntrinsicKind_EXP2 => 331
        case PackageFormat_IntrinsicKind.IntrinsicKind_LOG => 332
        case PackageFormat_IntrinsicKind.IntrinsicKind_LOG2 => 333
        case PackageFormat_IntrinsicKind.IntrinsicKind_LOG10 => 334
        case PackageFormat_IntrinsicKind.IntrinsicKind_SQRT => 335
        case PackageFormat_IntrinsicKind.IntrinsicKind_ROUND => 336
        case PackageFormat_IntrinsicKind.IntrinsicKind_POW => 337
        case PackageFormat_IntrinsicKind.IntrinsicKind_POWI => 338
        case PackageFormat_IntrinsicKind.IntrinsicKind_BIT_CAST => 339
        case PackageFormat_IntrinsicKind.IntrinsicKind_PREINITIALIZE => 340
        case PackageFormat_IntrinsicKind.IntrinsicKind_OBJECT_AS => 341
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_NULL => 342
        case PackageFormat_IntrinsicKind.IntrinsicKind_GET_TYPE_FOR_TYPE_PARAMETER => 343
        case PackageFormat_IntrinsicKind.IntrinsicKind_IS_SUBTYPE_TYPES => 344
     }
}

enum PackageFormat_TypeElem {
    TypeElem_NONE |
    TypeElem_RUNETYPE |
    TypeElem_BOOLEANTYPE |
    TypeElem_UNITTYPE |
    TypeElem_NOTHINGTYPE |
    TypeElem_INTTYPE |
    TypeElem_FLOATTYPE |
    TypeElem_TUPLETYPE |
    TypeElem_RAWARRAYTYPE |
    TypeElem_VARRAYTYPE |
    TypeElem_FUNCTYPE |
    TypeElem_CUSTOMTYPE |
    TypeElem_ENUMTYPE |
    TypeElem_STRUCTTYPE |
    TypeElem_CLASSTYPE |
    TypeElem_CSTRINGTYPE |
    TypeElem_CPOINTERTYPE |
    TypeElem_GENERICTYPE |
    TypeElem_REFTYPE |
    TypeElem_BOXTYPE |
    TypeElem_VOIDTYPE |
    TypeElem_THISTYPE
}

func EnumValuesPackageFormat_TypeElem(e: UInt8) : PackageFormat_TypeElem {
    var values: Array<PackageFormat_TypeElem> = [
        PackageFormat_TypeElem.TypeElem_NONE,
        PackageFormat_TypeElem.TypeElem_RUNETYPE,
        PackageFormat_TypeElem.TypeElem_BOOLEANTYPE,
        PackageFormat_TypeElem.TypeElem_UNITTYPE,
        PackageFormat_TypeElem.TypeElem_NOTHINGTYPE,
        PackageFormat_TypeElem.TypeElem_INTTYPE,
        PackageFormat_TypeElem.TypeElem_FLOATTYPE,
        PackageFormat_TypeElem.TypeElem_TUPLETYPE,
        PackageFormat_TypeElem.TypeElem_RAWARRAYTYPE,
        PackageFormat_TypeElem.TypeElem_VARRAYTYPE,
        PackageFormat_TypeElem.TypeElem_FUNCTYPE,
        PackageFormat_TypeElem.TypeElem_CUSTOMTYPE,
        PackageFormat_TypeElem.TypeElem_ENUMTYPE,
        PackageFormat_TypeElem.TypeElem_STRUCTTYPE,
        PackageFormat_TypeElem.TypeElem_CLASSTYPE,
        PackageFormat_TypeElem.TypeElem_CSTRINGTYPE,
        PackageFormat_TypeElem.TypeElem_CPOINTERTYPE,
        PackageFormat_TypeElem.TypeElem_GENERICTYPE,
        PackageFormat_TypeElem.TypeElem_REFTYPE,
        PackageFormat_TypeElem.TypeElem_BOXTYPE,
        PackageFormat_TypeElem.TypeElem_VOIDTYPE,
        PackageFormat_TypeElem.TypeElem_THISTYPE
    ]
    return if (e < 22) { values[Int64(e)] } else { TypeElem_NONE }
}

func EnumPackageFormat_TypeElemValues(e: PackageFormat_TypeElem) : UInt8 {
    return match (e) {
        case PackageFormat_TypeElem.TypeElem_NONE => 0
        case PackageFormat_TypeElem.TypeElem_RUNETYPE => 1
        case PackageFormat_TypeElem.TypeElem_BOOLEANTYPE => 2
        case PackageFormat_TypeElem.TypeElem_UNITTYPE => 3
        case PackageFormat_TypeElem.TypeElem_NOTHINGTYPE => 4
        case PackageFormat_TypeElem.TypeElem_INTTYPE => 5
        case PackageFormat_TypeElem.TypeElem_FLOATTYPE => 6
        case PackageFormat_TypeElem.TypeElem_TUPLETYPE => 7
        case PackageFormat_TypeElem.TypeElem_RAWARRAYTYPE => 8
        case PackageFormat_TypeElem.TypeElem_VARRAYTYPE => 9
        case PackageFormat_TypeElem.TypeElem_FUNCTYPE => 10
        case PackageFormat_TypeElem.TypeElem_CUSTOMTYPE => 11
        case PackageFormat_TypeElem.TypeElem_ENUMTYPE => 12
        case PackageFormat_TypeElem.TypeElem_STRUCTTYPE => 13
        case PackageFormat_TypeElem.TypeElem_CLASSTYPE => 14
        case PackageFormat_TypeElem.TypeElem_CSTRINGTYPE => 15
        case PackageFormat_TypeElem.TypeElem_CPOINTERTYPE => 16
        case PackageFormat_TypeElem.TypeElem_GENERICTYPE => 17
        case PackageFormat_TypeElem.TypeElem_REFTYPE => 18
        case PackageFormat_TypeElem.TypeElem_BOXTYPE => 19
        case PackageFormat_TypeElem.TypeElem_VOIDTYPE => 20
        case PackageFormat_TypeElem.TypeElem_THISTYPE => 21
     }
}

enum PackageFormat_CustomTypeDefElem {
    CustomTypeDefElem_NONE |
    CustomTypeDefElem_ENUMDEF |
    CustomTypeDefElem_STRUCTDEF |
    CustomTypeDefElem_CLASSDEF |
    CustomTypeDefElem_EXTENDDEF
}

func EnumValuesPackageFormat_CustomTypeDefElem(e: UInt8) : PackageFormat_CustomTypeDefElem {
    var values: Array<PackageFormat_CustomTypeDefElem> = [
        PackageFormat_CustomTypeDefElem.CustomTypeDefElem_NONE,
        PackageFormat_CustomTypeDefElem.CustomTypeDefElem_ENUMDEF,
        PackageFormat_CustomTypeDefElem.CustomTypeDefElem_STRUCTDEF,
        PackageFormat_CustomTypeDefElem.CustomTypeDefElem_CLASSDEF,
        PackageFormat_CustomTypeDefElem.CustomTypeDefElem_EXTENDDEF
    ]
    return if (e < 5) { values[Int64(e)] } else { CustomTypeDefElem_NONE }
}

func EnumPackageFormat_CustomTypeDefElemValues(e: PackageFormat_CustomTypeDefElem) : UInt8 {
    return match (e) {
        case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_NONE => 0
        case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_ENUMDEF => 1
        case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_STRUCTDEF => 2
        case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_CLASSDEF => 3
        case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_EXTENDDEF => 4
     }
}

enum PackageFormat_ExpressionElem {
    ExpressionElem_NONE |
    ExpressionElem_UNARYEXPRESSION |
    ExpressionElem_BINARYEXPRESSION |
    ExpressionElem_CONSTANT |
    ExpressionElem_ALLOCATE |
    ExpressionElem_LOAD |
    ExpressionElem_STORE |
    ExpressionElem_GETELEMENTREF |
    ExpressionElem_GETELEMENTBYNAME |
    ExpressionElem_STOREELEMENTREF |
    ExpressionElem_STOREELEMENTBYNAME |
    ExpressionElem_APPLY |
    ExpressionElem_INVOKE |
    ExpressionElem_TYPECAST |
    ExpressionElem_INSTANCEOF |
    ExpressionElem_BOX |
    ExpressionElem_UNBOX |
    ExpressionElem_GOTO |
    ExpressionElem_BRANCH |
    ExpressionElem_MULTIBRANCH |
    ExpressionElem_EXIT |
    ExpressionElem_RAISEEXCEPTION |
    ExpressionElem_APPLYWITHEXCEPTION |
    ExpressionElem_INVOKEWITHEXCEPTION |
    ExpressionElem_INTOPWITHEXCEPTION |
    ExpressionElem_TYPECASTWITHEXCEPTION |
    ExpressionElem_INTRINSICWITHEXCEPTION |
    ExpressionElem_ALLOCATEWITHEXCEPTION |
    ExpressionElem_RAWARRAYALLOCATEWITHEXCEPTION |
    ExpressionElem_SPAWNWITHEXCEPTION |
    ExpressionElem_TUPLE |
    ExpressionElem_FIELD |
    ExpressionElem_FIELDBYNAME |
    ExpressionElem_RAWARRAYALLOCATE |
    ExpressionElem_RAWARRAYLITERALINIT |
    ExpressionElem_RAWARRAYINITBYVALUE |
    ExpressionElem_VARRAY |
    ExpressionElem_VARRAYBD |
    ExpressionElem_GETEXCEPTION |
    ExpressionElem_INTRINSIC |
    ExpressionElem_IF |
    ExpressionElem_LOOP |
    ExpressionElem_FORINRANGE |
    ExpressionElem_FORINITER |
    ExpressionElem_FORINCLOSEDRANGE |
    ExpressionElem_DEBUG |
    ExpressionElem_SPAWN |
    ExpressionElem_LAMBDA |
    ExpressionElem_INVOKESTATIC |
    ExpressionElem_INVOKESTATICWITHEXCEPTION |
    ExpressionElem_GETINSTANTIATEVALUE |
    ExpressionElem_TRANSFORMTOCONCRETE |
    ExpressionElem_TRANSFORMTOGENERIC |
    ExpressionElem_UNBOXTOREF |
    ExpressionElem_GETRTTI |
    ExpressionElem_GETRTTISTATIC
}

func EnumValuesPackageFormat_ExpressionElem(e: UInt8) : PackageFormat_ExpressionElem {
    var values: Array<PackageFormat_ExpressionElem> = [
        PackageFormat_ExpressionElem.ExpressionElem_NONE,
        PackageFormat_ExpressionElem.ExpressionElem_UNARYEXPRESSION,
        PackageFormat_ExpressionElem.ExpressionElem_BINARYEXPRESSION,
        PackageFormat_ExpressionElem.ExpressionElem_CONSTANT,
        PackageFormat_ExpressionElem.ExpressionElem_ALLOCATE,
        PackageFormat_ExpressionElem.ExpressionElem_LOAD,
        PackageFormat_ExpressionElem.ExpressionElem_STORE,
        PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTREF,
        PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTBYNAME,
        PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTREF,
        PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTBYNAME,
        PackageFormat_ExpressionElem.ExpressionElem_APPLY,
        PackageFormat_ExpressionElem.ExpressionElem_INVOKE,
        PackageFormat_ExpressionElem.ExpressionElem_TYPECAST,
        PackageFormat_ExpressionElem.ExpressionElem_INSTANCEOF,
        PackageFormat_ExpressionElem.ExpressionElem_BOX,
        PackageFormat_ExpressionElem.ExpressionElem_UNBOX,
        PackageFormat_ExpressionElem.ExpressionElem_GOTO,
        PackageFormat_ExpressionElem.ExpressionElem_BRANCH,
        PackageFormat_ExpressionElem.ExpressionElem_MULTIBRANCH,
        PackageFormat_ExpressionElem.ExpressionElem_EXIT,
        PackageFormat_ExpressionElem.ExpressionElem_RAISEEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_APPLYWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_INVOKEWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_INTOPWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_TYPECASTWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_INTRINSICWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_ALLOCATEWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATEWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_SPAWNWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_TUPLE,
        PackageFormat_ExpressionElem.ExpressionElem_FIELD,
        PackageFormat_ExpressionElem.ExpressionElem_FIELDBYNAME,
        PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATE,
        PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYLITERALINIT,
        PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYINITBYVALUE,
        PackageFormat_ExpressionElem.ExpressionElem_VARRAY,
        PackageFormat_ExpressionElem.ExpressionElem_VARRAYBD,
        PackageFormat_ExpressionElem.ExpressionElem_GETEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_INTRINSIC,
        PackageFormat_ExpressionElem.ExpressionElem_IF,
        PackageFormat_ExpressionElem.ExpressionElem_LOOP,
        PackageFormat_ExpressionElem.ExpressionElem_FORINRANGE,
        PackageFormat_ExpressionElem.ExpressionElem_FORINITER,
        PackageFormat_ExpressionElem.ExpressionElem_FORINCLOSEDRANGE,
        PackageFormat_ExpressionElem.ExpressionElem_DEBUG,
        PackageFormat_ExpressionElem.ExpressionElem_SPAWN,
        PackageFormat_ExpressionElem.ExpressionElem_LAMBDA,
        PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATIC,
        PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATICWITHEXCEPTION,
        PackageFormat_ExpressionElem.ExpressionElem_GETINSTANTIATEVALUE,
        PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOCONCRETE,
        PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOGENERIC,
        PackageFormat_ExpressionElem.ExpressionElem_UNBOXTOREF,
        PackageFormat_ExpressionElem.ExpressionElem_GETRTTI,
        PackageFormat_ExpressionElem.ExpressionElem_GETRTTISTATIC
    ]
    return if (e < 56) { values[Int64(e)] } else { ExpressionElem_NONE }
}

func EnumPackageFormat_ExpressionElemValues(e: PackageFormat_ExpressionElem) : UInt8 {
    return match (e) {
        case PackageFormat_ExpressionElem.ExpressionElem_NONE => 0
        case PackageFormat_ExpressionElem.ExpressionElem_UNARYEXPRESSION => 1
        case PackageFormat_ExpressionElem.ExpressionElem_BINARYEXPRESSION => 2
        case PackageFormat_ExpressionElem.ExpressionElem_CONSTANT => 3
        case PackageFormat_ExpressionElem.ExpressionElem_ALLOCATE => 4
        case PackageFormat_ExpressionElem.ExpressionElem_LOAD => 5
        case PackageFormat_ExpressionElem.ExpressionElem_STORE => 6
        case PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTREF => 7
        case PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTBYNAME => 8
        case PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTREF => 9
        case PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTBYNAME => 10
        case PackageFormat_ExpressionElem.ExpressionElem_APPLY => 11
        case PackageFormat_ExpressionElem.ExpressionElem_INVOKE => 12
        case PackageFormat_ExpressionElem.ExpressionElem_TYPECAST => 13
        case PackageFormat_ExpressionElem.ExpressionElem_INSTANCEOF => 14
        case PackageFormat_ExpressionElem.ExpressionElem_BOX => 15
        case PackageFormat_ExpressionElem.ExpressionElem_UNBOX => 16
        case PackageFormat_ExpressionElem.ExpressionElem_GOTO => 17
        case PackageFormat_ExpressionElem.ExpressionElem_BRANCH => 18
        case PackageFormat_ExpressionElem.ExpressionElem_MULTIBRANCH => 19
        case PackageFormat_ExpressionElem.ExpressionElem_EXIT => 20
        case PackageFormat_ExpressionElem.ExpressionElem_RAISEEXCEPTION => 21
        case PackageFormat_ExpressionElem.ExpressionElem_APPLYWITHEXCEPTION => 22
        case PackageFormat_ExpressionElem.ExpressionElem_INVOKEWITHEXCEPTION => 23
        case PackageFormat_ExpressionElem.ExpressionElem_INTOPWITHEXCEPTION => 24
        case PackageFormat_ExpressionElem.ExpressionElem_TYPECASTWITHEXCEPTION => 25
        case PackageFormat_ExpressionElem.ExpressionElem_INTRINSICWITHEXCEPTION => 26
        case PackageFormat_ExpressionElem.ExpressionElem_ALLOCATEWITHEXCEPTION => 27
        case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATEWITHEXCEPTION => 28
        case PackageFormat_ExpressionElem.ExpressionElem_SPAWNWITHEXCEPTION => 29
        case PackageFormat_ExpressionElem.ExpressionElem_TUPLE => 30
        case PackageFormat_ExpressionElem.ExpressionElem_FIELD => 31
        case PackageFormat_ExpressionElem.ExpressionElem_FIELDBYNAME => 32
        case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATE => 33
        case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYLITERALINIT => 34
        case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYINITBYVALUE => 35
        case PackageFormat_ExpressionElem.ExpressionElem_VARRAY => 36
        case PackageFormat_ExpressionElem.ExpressionElem_VARRAYBD => 37
        case PackageFormat_ExpressionElem.ExpressionElem_GETEXCEPTION => 38
        case PackageFormat_ExpressionElem.ExpressionElem_INTRINSIC => 39
        case PackageFormat_ExpressionElem.ExpressionElem_IF => 40
        case PackageFormat_ExpressionElem.ExpressionElem_LOOP => 41
        case PackageFormat_ExpressionElem.ExpressionElem_FORINRANGE => 42
        case PackageFormat_ExpressionElem.ExpressionElem_FORINITER => 43
        case PackageFormat_ExpressionElem.ExpressionElem_FORINCLOSEDRANGE => 44
        case PackageFormat_ExpressionElem.ExpressionElem_DEBUG => 45
        case PackageFormat_ExpressionElem.ExpressionElem_SPAWN => 46
        case PackageFormat_ExpressionElem.ExpressionElem_LAMBDA => 47
        case PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATIC => 48
        case PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATICWITHEXCEPTION => 49
        case PackageFormat_ExpressionElem.ExpressionElem_GETINSTANTIATEVALUE => 50
        case PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOCONCRETE => 51
        case PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOGENERIC => 52
        case PackageFormat_ExpressionElem.ExpressionElem_UNBOXTOREF => 53
        case PackageFormat_ExpressionElem.ExpressionElem_GETRTTI => 54
        case PackageFormat_ExpressionElem.ExpressionElem_GETRTTISTATIC => 55
     }
}

enum PackageFormat_ValueElem {
    ValueElem_NONE |
    ValueElem_BOOLLITERAL |
    ValueElem_RUNELITERAL |
    ValueElem_STRINGLITERAL |
    ValueElem_INTLITERAL |
    ValueElem_FLOATLITERAL |
    ValueElem_UNITLITERAL |
    ValueElem_NULLLITERAL |
    ValueElem_PARAMETER |
    ValueElem_LOCALVAR |
    ValueElem_GLOBALVAR |
    ValueElem_FUNC |
    ValueElem_IMPORTEDVAR |
    ValueElem_IMPORTEDFUNC |
    ValueElem_BLOCK |
    ValueElem_BLOCKGROUP
}

func EnumValuesPackageFormat_ValueElem(e: UInt8) : PackageFormat_ValueElem {
    var values: Array<PackageFormat_ValueElem> = [
        PackageFormat_ValueElem.ValueElem_NONE,
        PackageFormat_ValueElem.ValueElem_BOOLLITERAL,
        PackageFormat_ValueElem.ValueElem_RUNELITERAL,
        PackageFormat_ValueElem.ValueElem_STRINGLITERAL,
        PackageFormat_ValueElem.ValueElem_INTLITERAL,
        PackageFormat_ValueElem.ValueElem_FLOATLITERAL,
        PackageFormat_ValueElem.ValueElem_UNITLITERAL,
        PackageFormat_ValueElem.ValueElem_NULLLITERAL,
        PackageFormat_ValueElem.ValueElem_PARAMETER,
        PackageFormat_ValueElem.ValueElem_LOCALVAR,
        PackageFormat_ValueElem.ValueElem_GLOBALVAR,
        PackageFormat_ValueElem.ValueElem_FUNC,
        PackageFormat_ValueElem.ValueElem_IMPORTEDVAR,
        PackageFormat_ValueElem.ValueElem_IMPORTEDFUNC,
        PackageFormat_ValueElem.ValueElem_BLOCK,
        PackageFormat_ValueElem.ValueElem_BLOCKGROUP
    ]
    return if (e < 16) { values[Int64(e)] } else { ValueElem_NONE }
}

func EnumPackageFormat_ValueElemValues(e: PackageFormat_ValueElem) : UInt8 {
    return match (e) {
        case PackageFormat_ValueElem.ValueElem_NONE => 0
        case PackageFormat_ValueElem.ValueElem_BOOLLITERAL => 1
        case PackageFormat_ValueElem.ValueElem_RUNELITERAL => 2
        case PackageFormat_ValueElem.ValueElem_STRINGLITERAL => 3
        case PackageFormat_ValueElem.ValueElem_INTLITERAL => 4
        case PackageFormat_ValueElem.ValueElem_FLOATLITERAL => 5
        case PackageFormat_ValueElem.ValueElem_UNITLITERAL => 6
        case PackageFormat_ValueElem.ValueElem_NULLLITERAL => 7
        case PackageFormat_ValueElem.ValueElem_PARAMETER => 8
        case PackageFormat_ValueElem.ValueElem_LOCALVAR => 9
        case PackageFormat_ValueElem.ValueElem_GLOBALVAR => 10
        case PackageFormat_ValueElem.ValueElem_FUNC => 11
        case PackageFormat_ValueElem.ValueElem_IMPORTEDVAR => 12
        case PackageFormat_ValueElem.ValueElem_IMPORTEDFUNC => 13
        case PackageFormat_ValueElem.ValueElem_BLOCK => 14
        case PackageFormat_ValueElem.ValueElem_BLOCKGROUP => 15
     }
}

enum PackageFormat_PackageAccessLevel {
    PackageAccessLevel_INVALID |
    PackageAccessLevel_INTERNAL |
    PackageAccessLevel_PROTECTED |
    PackageAccessLevel_PUBLIC
}

func EnumValuesPackageFormat_PackageAccessLevel(e: UInt8) : PackageFormat_PackageAccessLevel {
    var values: Array<PackageFormat_PackageAccessLevel> = [
        PackageFormat_PackageAccessLevel.PackageAccessLevel_INVALID,
        PackageFormat_PackageAccessLevel.PackageAccessLevel_INTERNAL,
        PackageFormat_PackageAccessLevel.PackageAccessLevel_PROTECTED,
        PackageFormat_PackageAccessLevel.PackageAccessLevel_PUBLIC
    ]
    return if (e < 4) { values[Int64(e)] } else { PackageAccessLevel_INVALID }
}

func EnumPackageFormat_PackageAccessLevelValues(e: PackageFormat_PackageAccessLevel) : UInt8 {
    return match (e) {
        case PackageFormat_PackageAccessLevel.PackageAccessLevel_INVALID => 0
        case PackageFormat_PackageAccessLevel.PackageAccessLevel_INTERNAL => 1
        case PackageFormat_PackageAccessLevel.PackageAccessLevel_PROTECTED => 2
        case PackageFormat_PackageAccessLevel.PackageAccessLevel_PUBLIC => 3
     }
}

enum PackageFormat_Phase {
    Phase_RAW |
    Phase_OPT |
    Phase_PLUGIN |
    Phase_ANALYSIS_FOR_CJLINT
}

func EnumValuesPackageFormat_Phase(e: UInt8) : PackageFormat_Phase {
    var values: Array<PackageFormat_Phase> = [
        PackageFormat_Phase.Phase_RAW,
        PackageFormat_Phase.Phase_OPT,
        PackageFormat_Phase.Phase_PLUGIN,
        PackageFormat_Phase.Phase_ANALYSIS_FOR_CJLINT
    ]
    return if (e < 4) { values[Int64(e)] } else { Phase_RAW }
}

func EnumPackageFormat_PhaseValues(e: PackageFormat_Phase) : UInt8 {
    return match (e) {
        case PackageFormat_Phase.Phase_RAW => 0
        case PackageFormat_Phase.Phase_OPT => 1
        case PackageFormat_Phase.Phase_PLUGIN => 2
        case PackageFormat_Phase.Phase_ANALYSIS_FOR_CJLINT => 3
     }
}

public class PackageFormat_Type <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let KIND : UInt16 = 4
    let TYPEID : UInt16 = 6
    let ARGTYS : UInt16 = 8
    let REFDIMS : UInt16 = 10

    func GetKind(): PackageFormat_CHIRTypeKind {
        let o : UInt32 = UInt32(this.table.offset(KIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_CHIRTypeKind.CHIRTypeKind_INVALID
        } else {
            EnumValuesPackageFormat_CHIRTypeKind(this.table.getUInt8(off))
        }
    }
    func GetTypeID(): UInt32 {
        return this.table.getUInt32Slot(TYPEID, 0)
    }
    func GetArgTys() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(ARGTYS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetRefDims(): UInt8 {
        return this.table.getUInt8Slot(REFDIMS, 0)
    }
    static func startType(builder: Builder): Unit { builder.startObject(4) }
    static func addKind(kind: PackageFormat_CHIRTypeKind, builder: Builder) {
        builder.prependUInt8Slot(0, EnumPackageFormat_CHIRTypeKindValues(kind), 0)
    }
    static func addTypeID(typeID: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, typeID, 0)
    }
    static func addArgTysVector(argTys: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, argTys, 0)
    }
    static func addRefDims(refDims: UInt8, builder: Builder) {
        builder.prependUInt8Slot(3, refDims, 0)
    }
    static func endType(builder: Builder): UInt32 {return builder.endObject()}
    static func createType(
        builder: Builder,
        kind: PackageFormat_CHIRTypeKind,
        typeID: UInt32,
        argTys: UInt32,
        refDims: UInt8
    ): UInt32 {
        PackageFormat_Type.startType(builder)
        PackageFormat_Type.addRefDims(refDims, builder)
        PackageFormat_Type.addArgTysVector(argTys, builder)
        PackageFormat_Type.addTypeID(typeID, builder)
        PackageFormat_Type.addKind(kind, builder)
        return PackageFormat_Type.endType(builder)
    }
}

public class PackageFormat_RuneType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startRuneType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endRuneType(builder: Builder): UInt32 {return builder.endObject()}
    static func createRuneType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_RuneType.startRuneType(builder)
        PackageFormat_RuneType.addExtendsVector(extends, builder)
        PackageFormat_RuneType.addBase(base, builder)
        return PackageFormat_RuneType.endRuneType(builder)
    }
}

public class PackageFormat_BooleanType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startBooleanType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endBooleanType(builder: Builder): UInt32 {return builder.endObject()}
    static func createBooleanType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_BooleanType.startBooleanType(builder)
        PackageFormat_BooleanType.addExtendsVector(extends, builder)
        PackageFormat_BooleanType.addBase(base, builder)
        return PackageFormat_BooleanType.endBooleanType(builder)
    }
}

public class PackageFormat_UnitType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startUnitType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endUnitType(builder: Builder): UInt32 {return builder.endObject()}
    static func createUnitType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_UnitType.startUnitType(builder)
        PackageFormat_UnitType.addExtendsVector(extends, builder)
        PackageFormat_UnitType.addBase(base, builder)
        return PackageFormat_UnitType.endUnitType(builder)
    }
}

public class PackageFormat_NothingType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startNothingType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endNothingType(builder: Builder): UInt32 {return builder.endObject()}
    static func createNothingType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_NothingType.startNothingType(builder)
        PackageFormat_NothingType.addExtendsVector(extends, builder)
        PackageFormat_NothingType.addBase(base, builder)
        return PackageFormat_NothingType.endNothingType(builder)
    }
}

public class PackageFormat_NumericType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startNumericType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endNumericType(builder: Builder): UInt32 {return builder.endObject()}
    static func createNumericType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_NumericType.startNumericType(builder)
        PackageFormat_NumericType.addExtendsVector(extends, builder)
        PackageFormat_NumericType.addBase(base, builder)
        return PackageFormat_NumericType.endNumericType(builder)
    }
}

public class PackageFormat_IntType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_NumericType> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_NumericType>
        } else {
            Some<PackageFormat_NumericType>(PackageFormat_NumericType(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startIntType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endIntType(builder: Builder): UInt32 {return builder.endObject()}
    static func createIntType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_IntType.startIntType(builder)
        PackageFormat_IntType.addBase(base, builder)
        return PackageFormat_IntType.endIntType(builder)
    }
}

public class PackageFormat_FloatType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_NumericType> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_NumericType>
        } else {
            Some<PackageFormat_NumericType>(PackageFormat_NumericType(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startFloatType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endFloatType(builder: Builder): UInt32 {return builder.endObject()}
    static func createFloatType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_FloatType.startFloatType(builder)
        PackageFormat_FloatType.addBase(base, builder)
        return PackageFormat_FloatType.endFloatType(builder)
    }
}

public class PackageFormat_TupleType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startTupleType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endTupleType(builder: Builder): UInt32 {return builder.endObject()}
    static func createTupleType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_TupleType.startTupleType(builder)
        PackageFormat_TupleType.addBase(base, builder)
        return PackageFormat_TupleType.endTupleType(builder)
    }
}

public class PackageFormat_RawArrayType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let DIMS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetDims(): UInt32 {
        return this.table.getUInt32Slot(DIMS, 0)
    }
    static func startRawArrayType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addDims(dims: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, dims, 0)
    }
    static func endRawArrayType(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayType(
        builder: Builder,
        base: UInt32,
        dims: UInt32
    ): UInt32 {
        PackageFormat_RawArrayType.startRawArrayType(builder)
        PackageFormat_RawArrayType.addDims(dims, builder)
        PackageFormat_RawArrayType.addBase(base, builder)
        return PackageFormat_RawArrayType.endRawArrayType(builder)
    }
}

public class PackageFormat_VArrayType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SIZE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSize(): Int64 {
        return this.table.getInt64Slot(SIZE, 0)
    }
    static func startVArrayType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSize(size: Int64, builder: Builder) {
        builder.prependInt64Slot(1, size, 0)
    }
    static func endVArrayType(builder: Builder): UInt32 {return builder.endObject()}
    static func createVArrayType(
        builder: Builder,
        base: UInt32,
        size: Int64
    ): UInt32 {
        PackageFormat_VArrayType.startVArrayType(builder)
        PackageFormat_VArrayType.addSize(size, builder)
        PackageFormat_VArrayType.addBase(base, builder)
        return PackageFormat_VArrayType.endVArrayType(builder)
    }
}

public class PackageFormat_FuncType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ISCFUNCTYPE : UInt16 = 6
    let HASVARARG : UInt16 = 8

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIsCFuncType(): Bool {
        let o : UInt16 = this.table.offset(ISCFUNCTYPE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetHasVarArg(): Bool {
        let o : UInt16 = this.table.offset(HASVARARG)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startFuncType(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIsCFuncType(isCFuncType: Bool, builder: Builder) {
        builder.prependBoolSlot(1, isCFuncType, false)
    }
    static func addHasVarArg(hasVarArg: Bool, builder: Builder) {
        builder.prependBoolSlot(2, hasVarArg, false)
    }
    static func endFuncType(builder: Builder): UInt32 {return builder.endObject()}
    static func createFuncType(
        builder: Builder,
        base: UInt32,
        isCFuncType: Bool,
        hasVarArg: Bool
    ): UInt32 {
        PackageFormat_FuncType.startFuncType(builder)
        PackageFormat_FuncType.addHasVarArg(hasVarArg, builder)
        PackageFormat_FuncType.addIsCFuncType(isCFuncType, builder)
        PackageFormat_FuncType.addBase(base, builder)
        return PackageFormat_FuncType.endFuncType(builder)
    }
}

public class PackageFormat_CustomType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let IMPLEMENTEDINTERFACETYS : UInt16 = 6
    let INSTANTIATEDMEMBERTYS : UInt16 = 8
    let CUSTOMTYPEDEF : UInt16 = 10
    let HASSETSUPERINTERFACE : UInt16 = 12
    let HASSETINSTMEMBERTY : UInt16 = 14

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetImplementedInterfaceTys() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(IMPLEMENTEDINTERFACETYS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetInstantiatedMemberTys() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDMEMBERTYS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetCustomTypeDef(): UInt32 {
        return this.table.getUInt32Slot(CUSTOMTYPEDEF, 0)
    }
    func GetHasSetSuperInterface(): Bool {
        let o : UInt16 = this.table.offset(HASSETSUPERINTERFACE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetHasSetInstMemberTy(): Bool {
        let o : UInt16 = this.table.offset(HASSETINSTMEMBERTY)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startCustomType(builder: Builder): Unit { builder.startObject(6) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addImplementedInterfaceTysVector(implementedInterfaceTys: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, implementedInterfaceTys, 0)
    }
    static func addInstantiatedMemberTysVector(instantiatedMemberTys: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, instantiatedMemberTys, 0)
    }
    static func addCustomTypeDef(customTypeDef: UInt32, builder: Builder) {
        builder.prependUInt32Slot(3, customTypeDef, 0)
    }
    static func addHasSetSuperInterface(hasSetSuperInterface: Bool, builder: Builder) {
        builder.prependBoolSlot(4, hasSetSuperInterface, false)
    }
    static func addHasSetInstMemberTy(hasSetInstMemberTy: Bool, builder: Builder) {
        builder.prependBoolSlot(5, hasSetInstMemberTy, false)
    }
    static func endCustomType(builder: Builder): UInt32 {return builder.endObject()}
    static func createCustomType(
        builder: Builder,
        base: UInt32,
        implementedInterfaceTys: UInt32,
        instantiatedMemberTys: UInt32,
        customTypeDef: UInt32,
        hasSetSuperInterface: Bool,
        hasSetInstMemberTy: Bool
    ): UInt32 {
        PackageFormat_CustomType.startCustomType(builder)
        PackageFormat_CustomType.addHasSetInstMemberTy(hasSetInstMemberTy, builder)
        PackageFormat_CustomType.addHasSetSuperInterface(hasSetSuperInterface, builder)
        PackageFormat_CustomType.addCustomTypeDef(customTypeDef, builder)
        PackageFormat_CustomType.addInstantiatedMemberTysVector(instantiatedMemberTys, builder)
        PackageFormat_CustomType.addImplementedInterfaceTysVector(implementedInterfaceTys, builder)
        PackageFormat_CustomType.addBase(base, builder)
        return PackageFormat_CustomType.endCustomType(builder)
    }
}

public class PackageFormat_EnumType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ISBOXED : UInt16 = 6

    func GetBase(): Option<PackageFormat_CustomType> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomType>
        } else {
            Some<PackageFormat_CustomType>(PackageFormat_CustomType(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIsBoxed(): Bool {
        let o : UInt16 = this.table.offset(ISBOXED)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startEnumType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIsBoxed(isBoxed: Bool, builder: Builder) {
        builder.prependBoolSlot(1, isBoxed, false)
    }
    static func endEnumType(builder: Builder): UInt32 {return builder.endObject()}
    static func createEnumType(
        builder: Builder,
        base: UInt32,
        isBoxed: Bool
    ): UInt32 {
        PackageFormat_EnumType.startEnumType(builder)
        PackageFormat_EnumType.addIsBoxed(isBoxed, builder)
        PackageFormat_EnumType.addBase(base, builder)
        return PackageFormat_EnumType.endEnumType(builder)
    }
}

public class PackageFormat_StructType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_CustomType> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomType>
        } else {
            Some<PackageFormat_CustomType>(PackageFormat_CustomType(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startStructType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endStructType(builder: Builder): UInt32 {return builder.endObject()}
    static func createStructType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_StructType.startStructType(builder)
        PackageFormat_StructType.addBase(base, builder)
        return PackageFormat_StructType.endStructType(builder)
    }
}

public class PackageFormat_ClassType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SUPERCLASSTY : UInt16 = 6
    let HASSETSUPERCLASS : UInt16 = 8

    func GetBase(): Option<PackageFormat_CustomType> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomType>
        } else {
            Some<PackageFormat_CustomType>(PackageFormat_CustomType(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSuperClassTy(): UInt32 {
        return this.table.getUInt32Slot(SUPERCLASSTY, 0)
    }
    func GetHasSetSuperClass(): Bool {
        let o : UInt16 = this.table.offset(HASSETSUPERCLASS)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startClassType(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSuperClassTy(superClassTy: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, superClassTy, 0)
    }
    static func addHasSetSuperClass(hasSetSuperClass: Bool, builder: Builder) {
        builder.prependBoolSlot(2, hasSetSuperClass, false)
    }
    static func endClassType(builder: Builder): UInt32 {return builder.endObject()}
    static func createClassType(
        builder: Builder,
        base: UInt32,
        superClassTy: UInt32,
        hasSetSuperClass: Bool
    ): UInt32 {
        PackageFormat_ClassType.startClassType(builder)
        PackageFormat_ClassType.addHasSetSuperClass(hasSetSuperClass, builder)
        PackageFormat_ClassType.addSuperClassTy(superClassTy, builder)
        PackageFormat_ClassType.addBase(base, builder)
        return PackageFormat_ClassType.endClassType(builder)
    }
}

public class PackageFormat_CStringType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startCStringType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endCStringType(builder: Builder): UInt32 {return builder.endObject()}
    static func createCStringType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_CStringType.startCStringType(builder)
        PackageFormat_CStringType.addExtendsVector(extends, builder)
        PackageFormat_CStringType.addBase(base, builder)
        return PackageFormat_CStringType.endCStringType(builder)
    }
}

public class PackageFormat_CPointerType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startCPointerType(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, extends, 0)
    }
    static func endCPointerType(builder: Builder): UInt32 {return builder.endObject()}
    static func createCPointerType(
        builder: Builder,
        base: UInt32,
        extends: UInt32
    ): UInt32 {
        PackageFormat_CPointerType.startCPointerType(builder)
        PackageFormat_CPointerType.addExtendsVector(extends, builder)
        PackageFormat_CPointerType.addBase(base, builder)
        return PackageFormat_CPointerType.endCPointerType(builder)
    }
}

public class PackageFormat_GenericType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ORPHANFLAG : UInt16 = 6
    let SKIPCHECK : UInt16 = 8
    let IDENTIFIER : UInt16 = 10
    let SRCCODEIDENTIFIER : UInt16 = 12
    let UPPERBOUNDS : UInt16 = 14

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOrphanFlag(): Bool {
        let o : UInt16 = this.table.offset(ORPHANFLAG)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetSkipCheck(): Bool {
        let o : UInt16 = this.table.offset(SKIPCHECK)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(IDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetUpperBounds() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(UPPERBOUNDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startGenericType(builder: Builder): Unit { builder.startObject(6) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOrphanFlag(orphanFlag: Bool, builder: Builder) {
        builder.prependBoolSlot(1, orphanFlag, false)
    }
    static func addSkipCheck(skipCheck: Bool, builder: Builder) {
        builder.prependBoolSlot(2, skipCheck, false)
    }
    static func addIdentifier(identifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, identifier, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, srcCodeIdentifier, 0)
    }
    static func addUpperBoundsVector(upperBounds: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, upperBounds, 0)
    }
    static func endGenericType(builder: Builder): UInt32 {return builder.endObject()}
    static func createGenericType(
        builder: Builder,
        base: UInt32,
        orphanFlag: Bool,
        skipCheck: Bool,
        identifier: UInt32,
        srcCodeIdentifier: UInt32,
        upperBounds: UInt32
    ): UInt32 {
        PackageFormat_GenericType.startGenericType(builder)
        PackageFormat_GenericType.addUpperBoundsVector(upperBounds, builder)
        PackageFormat_GenericType.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_GenericType.addIdentifier(identifier, builder)
        PackageFormat_GenericType.addSkipCheck(skipCheck, builder)
        PackageFormat_GenericType.addOrphanFlag(orphanFlag, builder)
        PackageFormat_GenericType.addBase(base, builder)
        return PackageFormat_GenericType.endGenericType(builder)
    }
}

public class PackageFormat_RefType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startRefType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endRefType(builder: Builder): UInt32 {return builder.endObject()}
    static func createRefType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_RefType.startRefType(builder)
        PackageFormat_RefType.addBase(base, builder)
        return PackageFormat_RefType.endRefType(builder)
    }
}

public class PackageFormat_BoxType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startBoxType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endBoxType(builder: Builder): UInt32 {return builder.endObject()}
    static func createBoxType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_BoxType.startBoxType(builder)
        PackageFormat_BoxType.addBase(base, builder)
        return PackageFormat_BoxType.endBoxType(builder)
    }
}

public class PackageFormat_VoidType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startVoidType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endVoidType(builder: Builder): UInt32 {return builder.endObject()}
    static func createVoidType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_VoidType.startVoidType(builder)
        PackageFormat_VoidType.addBase(base, builder)
        return PackageFormat_VoidType.endVoidType(builder)
    }
}

public class PackageFormat_ThisType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Type> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Type>
        } else {
            Some<PackageFormat_Type>(PackageFormat_Type(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startThisType(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endThisType(builder: Builder): UInt32 {return builder.endObject()}
    static func createThisType(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_ThisType.startThisType(builder)
        PackageFormat_ThisType.addBase(base, builder)
        return PackageFormat_ThisType.endThisType(builder)
    }
}

public class PackageFormat_Pos <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let LINE : UInt16 = 4
    let COLUMN : UInt16 = 6

    func GetLine(): UInt32 {
        return this.table.getUInt32Slot(LINE, 0)
    }
    func GetColumn(): UInt32 {
        return this.table.getUInt32Slot(COLUMN, 0)
    }
    static func startPos(builder: Builder): Unit { builder.startObject(2) }
    static func addLine(line: UInt32, builder: Builder) {
        builder.prependUInt32Slot(0, line, 0)
    }
    static func addColumn(column: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, column, 0)
    }
    static func endPos(builder: Builder): UInt32 {return builder.endObject()}
    static func createPos(
        builder: Builder,
        line: UInt32,
        column: UInt32
    ): UInt32 {
        PackageFormat_Pos.startPos(builder)
        PackageFormat_Pos.addColumn(column, builder)
        PackageFormat_Pos.addLine(line, builder)
        return PackageFormat_Pos.endPos(builder)
    }
}

public class PackageFormat_DebugLocation <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let FILEPATH : UInt16 = 4
    let FILEID : UInt16 = 6
    let BEGINPOS : UInt16 = 8
    let ENDPOS : UInt16 = 10
    let SCOPE : UInt16 = 12

    func GetFilePath(): String {
        let o : UInt32 = UInt32(this.table.offset(FILEPATH)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetFileId(): UInt32 {
        return this.table.getUInt32Slot(FILEID, 0)
    }
    func GetBeginPos(): Option<PackageFormat_Pos> {
        let o : UInt16 = this.table.offset(BEGINPOS)
        return if (o == 0) {
            None<PackageFormat_Pos>
        } else {
            Some<PackageFormat_Pos>(PackageFormat_Pos(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetEndPos(): Option<PackageFormat_Pos> {
        let o : UInt16 = this.table.offset(ENDPOS)
        return if (o == 0) {
            None<PackageFormat_Pos>
        } else {
            Some<PackageFormat_Pos>(PackageFormat_Pos(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetScope() : Array<Int32> {
        let o : UInt32 = UInt32(this.table.offset(SCOPE))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<Int32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getInt32(vecElement)
        }
    }
    static func startDebugLocation(builder: Builder): Unit { builder.startObject(5) }
    static func addFilePath(filePath: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, filePath, 0)
    }
    static func addFileId(fileId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, fileId, 0)
    }
    static func addBeginPos(beginPos: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, beginPos, 0)
    }
    static func addEndPos(endPos: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, endPos, 0)
    }
    static func addScopeVector(scope: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, scope, 0)
    }
    static func endDebugLocation(builder: Builder): UInt32 {return builder.endObject()}
    static func createDebugLocation(
        builder: Builder,
        filePath: UInt32,
        fileId: UInt32,
        beginPos: UInt32,
        endPos: UInt32,
        scope: UInt32
    ): UInt32 {
        PackageFormat_DebugLocation.startDebugLocation(builder)
        PackageFormat_DebugLocation.addScopeVector(scope, builder)
        PackageFormat_DebugLocation.addEndPos(endPos, builder)
        PackageFormat_DebugLocation.addBeginPos(beginPos, builder)
        PackageFormat_DebugLocation.addFileId(fileId, builder)
        PackageFormat_DebugLocation.addFilePath(filePath, builder)
        return PackageFormat_DebugLocation.endDebugLocation(builder)
    }
}

public class PackageFormat_LinkTypeInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let LINKAGE : UInt16 = 4

    func GetLinkage(): PackageFormat_Linkage {
        let o : UInt32 = UInt32(this.table.offset(LINKAGE))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_Linkage.Linkage_WEAK_ODR
        } else {
            EnumValuesPackageFormat_Linkage(this.table.getInt16(off))
        }
    }
    static func startLinkTypeInfo(builder: Builder): Unit { builder.startObject(1) }
    static func addLinkage(linkage: PackageFormat_Linkage, builder: Builder) {
        builder.prependInt16Slot(0, EnumPackageFormat_LinkageValues(linkage), 0)
    }
    static func endLinkTypeInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createLinkTypeInfo(
        builder: Builder,
        linkage: PackageFormat_Linkage
    ): UInt32 {
        PackageFormat_LinkTypeInfo.startLinkTypeInfo(builder)
        PackageFormat_LinkTypeInfo.addLinkage(linkage, builder)
        return PackageFormat_LinkTypeInfo.endLinkTypeInfo(builder)
    }
}

public class PackageFormat_SkipCheck <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let SKIPKIND : UInt16 = 4

    func GetSkipKind(): PackageFormat_SkipKind {
        let o : UInt32 = UInt32(this.table.offset(SKIPKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_SkipKind.SkipKind_NO_SKIP
        } else {
            EnumValuesPackageFormat_SkipKind(this.table.getUInt8(off))
        }
    }
    static func startSkipCheck(builder: Builder): Unit { builder.startObject(1) }
    static func addSkipKind(skipKind: PackageFormat_SkipKind, builder: Builder) {
        builder.prependUInt8Slot(0, EnumPackageFormat_SkipKindValues(skipKind), 0)
    }
    static func endSkipCheck(builder: Builder): UInt32 {return builder.endObject()}
    static func createSkipCheck(
        builder: Builder,
        skipKind: PackageFormat_SkipKind
    ): UInt32 {
        PackageFormat_SkipCheck.startSkipCheck(builder)
        PackageFormat_SkipCheck.addSkipKind(skipKind, builder)
        return PackageFormat_SkipCheck.endSkipCheck(builder)
    }
}

public class PackageFormat_NeedCheckArrayBound <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let NEED : UInt16 = 4

    func GetNeed(): Bool {
        let o : UInt16 = this.table.offset(NEED)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startNeedCheckArrayBound(builder: Builder): Unit { builder.startObject(1) }
    static func addNeed(need: Bool, builder: Builder) {
        builder.prependBoolSlot(0, need, true)
    }
    static func endNeedCheckArrayBound(builder: Builder): UInt32 {return builder.endObject()}
    static func createNeedCheckArrayBound(
        builder: Builder,
        need: Bool
    ): UInt32 {
        PackageFormat_NeedCheckArrayBound.startNeedCheckArrayBound(builder)
        PackageFormat_NeedCheckArrayBound.addNeed(need, builder)
        return PackageFormat_NeedCheckArrayBound.endNeedCheckArrayBound(builder)
    }
}

public class PackageFormat_NeedCheckCast <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let NEED : UInt16 = 4

    func GetNeed(): Bool {
        let o : UInt16 = this.table.offset(NEED)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startNeedCheckCast(builder: Builder): Unit { builder.startObject(1) }
    static func addNeed(need: Bool, builder: Builder) {
        builder.prependBoolSlot(0, need, true)
    }
    static func endNeedCheckCast(builder: Builder): UInt32 {return builder.endObject()}
    static func createNeedCheckCast(
        builder: Builder,
        need: Bool
    ): UInt32 {
        PackageFormat_NeedCheckCast.startNeedCheckCast(builder)
        PackageFormat_NeedCheckCast.addNeed(need, builder)
        return PackageFormat_NeedCheckCast.endNeedCheckCast(builder)
    }
}

public class PackageFormat_NeverOverflowInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let NEVEROVERFLOW : UInt16 = 4

    func GetNeverOverflow(): Bool {
        let o : UInt16 = this.table.offset(NEVEROVERFLOW)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startNeverOverflowInfo(builder: Builder): Unit { builder.startObject(1) }
    static func addNeverOverflow(neverOverflow: Bool, builder: Builder) {
        builder.prependBoolSlot(0, neverOverflow, false)
    }
    static func endNeverOverflowInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createNeverOverflowInfo(
        builder: Builder,
        neverOverflow: Bool
    ): UInt32 {
        PackageFormat_NeverOverflowInfo.startNeverOverflowInfo(builder)
        PackageFormat_NeverOverflowInfo.addNeverOverflow(neverOverflow, builder)
        return PackageFormat_NeverOverflowInfo.endNeverOverflowInfo(builder)
    }
}

public class PackageFormat_GeneratedFromForIn <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let VALUE : UInt16 = 4

    func GetValue(): Bool {
        let o : UInt16 = this.table.offset(VALUE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startGeneratedFromForIn(builder: Builder): Unit { builder.startObject(1) }
    static func addValue(value: Bool, builder: Builder) {
        builder.prependBoolSlot(0, value, false)
    }
    static func endGeneratedFromForIn(builder: Builder): UInt32 {return builder.endObject()}
    static func createGeneratedFromForIn(
        builder: Builder,
        value: Bool
    ): UInt32 {
        PackageFormat_GeneratedFromForIn.startGeneratedFromForIn(builder)
        PackageFormat_GeneratedFromForIn.addValue(value, builder)
        return PackageFormat_GeneratedFromForIn.endGeneratedFromForIn(builder)
    }
}

public class PackageFormat_IsAutoEnvClass <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let VALUE : UInt16 = 4

    func GetValue(): Bool {
        let o : UInt16 = this.table.offset(VALUE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startIsAutoEnvClass(builder: Builder): Unit { builder.startObject(1) }
    static func addValue(value: Bool, builder: Builder) {
        builder.prependBoolSlot(0, value, false)
    }
    static func endIsAutoEnvClass(builder: Builder): UInt32 {return builder.endObject()}
    static func createIsAutoEnvClass(
        builder: Builder,
        value: Bool
    ): UInt32 {
        PackageFormat_IsAutoEnvClass.startIsAutoEnvClass(builder)
        PackageFormat_IsAutoEnvClass.addValue(value, builder)
        return PackageFormat_IsAutoEnvClass.endIsAutoEnvClass(builder)
    }
}

public class PackageFormat_IsCapturedClassInCC <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let VALUE : UInt16 = 4

    func GetValue(): Bool {
        let o : UInt16 = this.table.offset(VALUE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startIsCapturedClassInCC(builder: Builder): Unit { builder.startObject(1) }
    static func addValue(value: Bool, builder: Builder) {
        builder.prependBoolSlot(0, value, false)
    }
    static func endIsCapturedClassInCC(builder: Builder): UInt32 {return builder.endObject()}
    static func createIsCapturedClassInCC(
        builder: Builder,
        value: Bool
    ): UInt32 {
        PackageFormat_IsCapturedClassInCC.startIsCapturedClassInCC(builder)
        PackageFormat_IsCapturedClassInCC.addValue(value, builder)
        return PackageFormat_IsCapturedClassInCC.endIsCapturedClassInCC(builder)
    }
}

public class PackageFormat_EnumCaseIndex <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let INDEX : UInt16 = 4

    func GetIndex(): Int64 {
        return this.table.getInt64Slot(INDEX, -1)
    }
    static func startEnumCaseIndex(builder: Builder): Unit { builder.startObject(1) }
    static func addIndex(index: Int64, builder: Builder) {
        builder.prependInt64Slot(0, index, -1)
    }
    static func endEnumCaseIndex(builder: Builder): UInt32 {return builder.endObject()}
    static func createEnumCaseIndex(
        builder: Builder,
        index: Int64
    ): UInt32 {
        PackageFormat_EnumCaseIndex.startEnumCaseIndex(builder)
        PackageFormat_EnumCaseIndex.addIndex(index, builder)
        return PackageFormat_EnumCaseIndex.endEnumCaseIndex(builder)
    }
}

public class PackageFormat_VirMethodOffset <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let OFFSET : UInt16 = 4

    func GetOffset(): Int64 {
        return this.table.getInt64Slot(OFFSET, -1)
    }
    static func startVirMethodOffset(builder: Builder): Unit { builder.startObject(1) }
    static func addOffset(offset: Int64, builder: Builder) {
        builder.prependInt64Slot(0, offset, -1)
    }
    static func endVirMethodOffset(builder: Builder): UInt32 {return builder.endObject()}
    static func createVirMethodOffset(
        builder: Builder,
        offset: Int64
    ): UInt32 {
        PackageFormat_VirMethodOffset.startVirMethodOffset(builder)
        PackageFormat_VirMethodOffset.addOffset(offset, builder)
        return PackageFormat_VirMethodOffset.endVirMethodOffset(builder)
    }
}

public class PackageFormat_WrappedRawMethod <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let RAWMETHOD : UInt16 = 4

    func GetRawMethod(): UInt32 {
        return this.table.getUInt32Slot(RAWMETHOD, 0)
    }
    static func startWrappedRawMethod(builder: Builder): Unit { builder.startObject(1) }
    static func addRawMethod(rawMethod: UInt32, builder: Builder) {
        builder.prependUInt32Slot(0, rawMethod, 0)
    }
    static func endWrappedRawMethod(builder: Builder): UInt32 {return builder.endObject()}
    static func createWrappedRawMethod(
        builder: Builder,
        rawMethod: UInt32
    ): UInt32 {
        PackageFormat_WrappedRawMethod.startWrappedRawMethod(builder)
        PackageFormat_WrappedRawMethod.addRawMethod(rawMethod, builder)
        return PackageFormat_WrappedRawMethod.endWrappedRawMethod(builder)
    }
}

public class PackageFormat_OverrideSrcFuncType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let TYPE : UInt16 = 4

    func GetType(): UInt32 {
        return this.table.getUInt32Slot(TYPE, 0)
    }
    static func startOverrideSrcFuncType(builder: Builder): Unit { builder.startObject(1) }
    static func addType(type_: UInt32, builder: Builder) {
        builder.prependUInt32Slot(0, type_, 0)
    }
    static func endOverrideSrcFuncType(builder: Builder): UInt32 {return builder.endObject()}
    static func createOverrideSrcFuncType(
        builder: Builder,
        type_: UInt32
    ): UInt32 {
        PackageFormat_OverrideSrcFuncType.startOverrideSrcFuncType(builder)
        PackageFormat_OverrideSrcFuncType.addType(type_, builder)
        return PackageFormat_OverrideSrcFuncType.endOverrideSrcFuncType(builder)
    }
}

public class PackageFormat_VariantTypeCastWrapper <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let LAMBDACACHE : UInt16 = 4

    func GetLambdaCache() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(LAMBDACACHE))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startVariantTypeCastWrapper(builder: Builder): Unit { builder.startObject(1) }
    static func addLambdaCacheVector(lambdaCache: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, lambdaCache, 0)
    }
    static func endVariantTypeCastWrapper(builder: Builder): UInt32 {return builder.endObject()}
    static func createVariantTypeCastWrapper(
        builder: Builder,
        lambdaCache: UInt32
    ): UInt32 {
        PackageFormat_VariantTypeCastWrapper.startVariantTypeCastWrapper(builder)
        PackageFormat_VariantTypeCastWrapper.addLambdaCacheVector(lambdaCache, builder)
        return PackageFormat_VariantTypeCastWrapper.endVariantTypeCastWrapper(builder)
    }
}

public class PackageFormat_Base <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let ANNOS_TYPE : UInt16 = 4
    let ANNOS : UInt16 = 6

    func GetAnnosType() : Array<Option<PackageFormat_Annotation>> {
        let ELEMENT_STRIDE: UInt32 = 1
        let LENGTH: Int64 = this.table.getVectorLenBySlot(ANNOS_TYPE)
        var arr = Array<?PackageFormat_Annotation>(LENGTH, repeat: None<PackageFormat_Annotation>)
        let start: UInt32 = this.table.getVectorStartBySlot(ANNOS_TYPE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                EnumValuesPackageFormat_Annotation(0)
            } else {
                EnumValuesPackageFormat_Annotation(this.table.getUInt8(p))
            }
        }
        return arr
    }
    func GetAnnos(index: Int32) : FlatBufferObject {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorLoc: UInt32 = this.table.getIndirect(UInt32(o) + this.table.pos)
        let vectorStart = vectorLoc + 4
        if (o == 0) {
            FlatBufferObject(Array<UInt8>(), 0)
        } else {
            table.getUnion(vectorStart + UInt32(index) * 4)
        }
    }
    func GetAnnosSize(): Int64 {
        table.getVectorLenBySlot(ANNOS_TYPE)
    }
    func GetAnnosType(index: UInt32): PackageFormat_Annotation {
        let start = this.table.getVectorStartBySlot(ANNOS_TYPE)
        EnumValuesPackageFormat_Annotation(this.table.getUInt8(start + index))
    }

    func GetAnnosAsNeedCheckArrayBound(index: UInt32) : ?PackageFormat_NeedCheckArrayBound {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_NEEDCHECKARRAYBOUND => Some(PackageFormat_NeedCheckArrayBound(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_NeedCheckArrayBound>
        }
    }

    func GetAnnosAsNeedCheckCast(index: UInt32) : ?PackageFormat_NeedCheckCast {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_NEEDCHECKCAST => Some(PackageFormat_NeedCheckCast(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_NeedCheckCast>
        }
    }

    func GetAnnosAsDebugLocationInfo(index: UInt32) : ?PackageFormat_DebugLocation {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFO => Some(PackageFormat_DebugLocation(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_DebugLocation>
        }
    }

    func GetAnnosAsDebugLocationInfoForWarning(index: UInt32) : ?PackageFormat_DebugLocation {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_DEBUGLOCATIONINFOFORWARNING => Some(PackageFormat_DebugLocation(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_DebugLocation>
        }
    }

    func GetAnnosAsGeneratedFromForIn(index: UInt32) : ?PackageFormat_GeneratedFromForIn {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_GENERATEDFROMFORIN => Some(PackageFormat_GeneratedFromForIn(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GeneratedFromForIn>
        }
    }

    func GetAnnosAsIsAutoEnvClass(index: UInt32) : ?PackageFormat_IsAutoEnvClass {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_ISAUTOENVCLASS => Some(PackageFormat_IsAutoEnvClass(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IsAutoEnvClass>
        }
    }

    func GetAnnosAsIsCapturedClassInCC(index: UInt32) : ?PackageFormat_IsCapturedClassInCC {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_ISCAPTUREDCLASSINCC => Some(PackageFormat_IsCapturedClassInCC(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IsCapturedClassInCC>
        }
    }

    func GetAnnosAsLinkTypeInfo(index: UInt32) : ?PackageFormat_LinkTypeInfo {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_LINKTYPEINFO => Some(PackageFormat_LinkTypeInfo(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_LinkTypeInfo>
        }
    }

    func GetAnnosAsSkipCheck(index: UInt32) : ?PackageFormat_SkipCheck {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_SKIPCHECK => Some(PackageFormat_SkipCheck(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_SkipCheck>
        }
    }

    func GetAnnosAsNeverOverflowInfo(index: UInt32) : ?PackageFormat_NeverOverflowInfo {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_NEVEROVERFLOWINFO => Some(PackageFormat_NeverOverflowInfo(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_NeverOverflowInfo>
        }
    }

    func GetAnnosAsEnumCaseIndex(index: UInt32) : ?PackageFormat_EnumCaseIndex {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_ENUMCASEINDEX => Some(PackageFormat_EnumCaseIndex(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_EnumCaseIndex>
        }
    }

    func GetAnnosAsVirMethodOffset(index: UInt32) : ?PackageFormat_VirMethodOffset {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_VIRMETHODOFFSET => Some(PackageFormat_VirMethodOffset(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VirMethodOffset>
        }
    }

    func GetAnnosAsWrappedRawMethod(index: UInt32) : ?PackageFormat_WrappedRawMethod {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_WRAPPEDRAWMETHOD => Some(PackageFormat_WrappedRawMethod(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_WrappedRawMethod>
        }
    }

    func GetAnnosAsVariantTypeCastWrapper(index: UInt32) : ?PackageFormat_VariantTypeCastWrapper {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_VARIANTTYPECASTWRAPPER => Some(PackageFormat_VariantTypeCastWrapper(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VariantTypeCastWrapper>
        }
    }

    func GetAnnosAsOverrideSrcFuncType(index: UInt32) : ?PackageFormat_OverrideSrcFuncType {
        let o : UInt16 = this.table.offset(ANNOS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetAnnosType(index)) {
            case PackageFormat_Annotation.Annotation_OVERRIDESRCFUNCTYPE => Some(PackageFormat_OverrideSrcFuncType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_OverrideSrcFuncType>
        }
    }

    static func startBase(builder: Builder): Unit { builder.startObject(2) }
    static func addAnnosTypeVector(annosType: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, annosType, 0)
    }
    static func addAnnosVector(annos: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, annos, 0)
    }
    static func endBase(builder: Builder): UInt32 {return builder.endObject()}
    static func createBase(
        builder: Builder,
        annosType: UInt32,
        annos: UInt32
    ): UInt32 {
        PackageFormat_Base.startBase(builder)
        PackageFormat_Base.addAnnosVector(annos, builder)
        PackageFormat_Base.addAnnosTypeVector(annosType, builder)
        return PackageFormat_Base.endBase(builder)
    }
}

public class PackageFormat_Value <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let TYPE : UInt16 = 6
    let IDENTIFIER : UInt16 = 8
    let KIND : UInt16 = 10
    let VALUEID : UInt16 = 12
    let ATTRIBUTES : UInt16 = 14
    let ANNOINFO : UInt16 = 16

    func GetBase(): Option<PackageFormat_Base> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Base>
        } else {
            Some<PackageFormat_Base>(PackageFormat_Base(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetType(): UInt32 {
        return this.table.getUInt32Slot(TYPE, 0)
    }
    func GetIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(IDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetKind(): PackageFormat_ValueKind {
        let o : UInt32 = UInt32(this.table.offset(KIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_ValueKind.ValueKind_LITERAL
        } else {
            EnumValuesPackageFormat_ValueKind(this.table.getUInt8(off))
        }
    }
    func GetValueID(): UInt32 {
        return this.table.getUInt32Slot(VALUEID, 0)
    }
    func GetAttributes(): UInt64 {
        return this.table.getUInt64Slot(ATTRIBUTES, 0)
    }
    func GetAnnoInfo(): Option<PackageFormat_AnnoInfo> {
        let o : UInt16 = this.table.offset(ANNOINFO)
        return if (o == 0) {
            None<PackageFormat_AnnoInfo>
        } else {
            Some<PackageFormat_AnnoInfo>(PackageFormat_AnnoInfo(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startValue(builder: Builder): Unit { builder.startObject(7) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addType(type_: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, type_, 0)
    }
    static func addIdentifier(identifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, identifier, 0)
    }
    static func addKind(kind: PackageFormat_ValueKind, builder: Builder) {
        builder.prependUInt8Slot(3, EnumPackageFormat_ValueKindValues(kind), 0)
    }
    static func addValueID(valueID: UInt32, builder: Builder) {
        builder.prependUInt32Slot(4, valueID, 0)
    }
    static func addAttributes(attributes: UInt64, builder: Builder) {
        builder.prependUInt64Slot(5, attributes, 0)
    }
    static func addAnnoInfo(annoInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(6, annoInfo, 0)
    }
    static func endValue(builder: Builder): UInt32 {return builder.endObject()}
    static func createValue(
        builder: Builder,
        base: UInt32,
        type_: UInt32,
        identifier: UInt32,
        kind: PackageFormat_ValueKind,
        valueID: UInt32,
        attributes: UInt64,
        annoInfo: UInt32
    ): UInt32 {
        PackageFormat_Value.startValue(builder)
        PackageFormat_Value.addAnnoInfo(annoInfo, builder)
        PackageFormat_Value.addAttributes(attributes, builder)
        PackageFormat_Value.addValueID(valueID, builder)
        PackageFormat_Value.addKind(kind, builder)
        PackageFormat_Value.addIdentifier(identifier, builder)
        PackageFormat_Value.addType(type_, builder)
        PackageFormat_Value.addBase(base, builder)
        return PackageFormat_Value.endValue(builder)
    }
}

public class PackageFormat_LiteralValue <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let LITERALKIND : UInt16 = 6

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetLiteralKind(): PackageFormat_ConstantValueKind {
        let o : UInt32 = UInt32(this.table.offset(LITERALKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_ConstantValueKind.ConstantValueKind_BOOL
        } else {
            EnumValuesPackageFormat_ConstantValueKind(this.table.getUInt8(off))
        }
    }
    static func startLiteralValue(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addLiteralKind(literalKind: PackageFormat_ConstantValueKind, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_ConstantValueKindValues(literalKind), 0)
    }
    static func endLiteralValue(builder: Builder): UInt32 {return builder.endObject()}
    static func createLiteralValue(
        builder: Builder,
        base: UInt32,
        literalKind: PackageFormat_ConstantValueKind
    ): UInt32 {
        PackageFormat_LiteralValue.startLiteralValue(builder)
        PackageFormat_LiteralValue.addLiteralKind(literalKind, builder)
        PackageFormat_LiteralValue.addBase(base, builder)
        return PackageFormat_LiteralValue.endLiteralValue(builder)
    }
}

public class PackageFormat_BoolLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let VAL : UInt16 = 6

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVal(): Bool {
        let o : UInt16 = this.table.offset(VAL)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startBoolLiteral(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addVal(val: Bool, builder: Builder) {
        builder.prependBoolSlot(1, val, false)
    }
    static func endBoolLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createBoolLiteral(
        builder: Builder,
        base: UInt32,
        val: Bool
    ): UInt32 {
        PackageFormat_BoolLiteral.startBoolLiteral(builder)
        PackageFormat_BoolLiteral.addVal(val, builder)
        PackageFormat_BoolLiteral.addBase(base, builder)
        return PackageFormat_BoolLiteral.endBoolLiteral(builder)
    }
}

public class PackageFormat_StringLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let VAL : UInt16 = 6

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVal(): String {
        let o : UInt32 = UInt32(this.table.offset(VAL)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    static func startStringLiteral(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addVal(val: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, val, 0)
    }
    static func endStringLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createStringLiteral(
        builder: Builder,
        base: UInt32,
        val: UInt32
    ): UInt32 {
        PackageFormat_StringLiteral.startStringLiteral(builder)
        PackageFormat_StringLiteral.addVal(val, builder)
        PackageFormat_StringLiteral.addBase(base, builder)
        return PackageFormat_StringLiteral.endStringLiteral(builder)
    }
}

public class PackageFormat_RuneLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let VAL : UInt16 = 6

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVal(): UInt32 {
        return this.table.getUInt32Slot(VAL, 0)
    }
    static func startRuneLiteral(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addVal(val: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, val, 0)
    }
    static func endRuneLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createRuneLiteral(
        builder: Builder,
        base: UInt32,
        val: UInt32
    ): UInt32 {
        PackageFormat_RuneLiteral.startRuneLiteral(builder)
        PackageFormat_RuneLiteral.addVal(val, builder)
        PackageFormat_RuneLiteral.addBase(base, builder)
        return PackageFormat_RuneLiteral.endRuneLiteral(builder)
    }
}

public class PackageFormat_IntLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let VAL : UInt16 = 6

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVal(): UInt64 {
        return this.table.getUInt64Slot(VAL, 0)
    }
    static func startIntLiteral(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addVal(val: UInt64, builder: Builder) {
        builder.prependUInt64Slot(1, val, 0)
    }
    static func endIntLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createIntLiteral(
        builder: Builder,
        base: UInt32,
        val: UInt64
    ): UInt32 {
        PackageFormat_IntLiteral.startIntLiteral(builder)
        PackageFormat_IntLiteral.addVal(val, builder)
        PackageFormat_IntLiteral.addBase(base, builder)
        return PackageFormat_IntLiteral.endIntLiteral(builder)
    }
}

public class PackageFormat_FloatLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let VAL : UInt16 = 6

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVal(): Float64 {
        return this.table.getFloat64Slot(VAL, 1.0)
    }
    static func startFloatLiteral(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addVal(val: Float64, builder: Builder) {
        builder.prependFloat64Slot(1, val, 1.0)
    }
    static func endFloatLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createFloatLiteral(
        builder: Builder,
        base: UInt32,
        val: Float64
    ): UInt32 {
        PackageFormat_FloatLiteral.startFloatLiteral(builder)
        PackageFormat_FloatLiteral.addVal(val, builder)
        PackageFormat_FloatLiteral.addBase(base, builder)
        return PackageFormat_FloatLiteral.endFloatLiteral(builder)
    }
}

public class PackageFormat_UnitLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startUnitLiteral(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endUnitLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createUnitLiteral(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_UnitLiteral.startUnitLiteral(builder)
        PackageFormat_UnitLiteral.addBase(base, builder)
        return PackageFormat_UnitLiteral.endUnitLiteral(builder)
    }
}

public class PackageFormat_NullLiteral <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_LiteralValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_LiteralValue>
        } else {
            Some<PackageFormat_LiteralValue>(PackageFormat_LiteralValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startNullLiteral(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endNullLiteral(builder: Builder): UInt32 {return builder.endObject()}
    static func createNullLiteral(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_NullLiteral.startNullLiteral(builder)
        PackageFormat_NullLiteral.addBase(base, builder)
        return PackageFormat_NullLiteral.endNullLiteral(builder)
    }
}

public class PackageFormat_Parameter <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let OWNEDFUNC : UInt16 = 6
    let OWNEDLAMBDA : UInt16 = 8

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOwnedFunc(): UInt32 {
        return this.table.getUInt32Slot(OWNEDFUNC, 0)
    }
    func GetOwnedLambda(): UInt32 {
        return this.table.getUInt32Slot(OWNEDLAMBDA, 0)
    }
    static func startParameter(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOwnedFunc(ownedFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, ownedFunc, 0)
    }
    static func addOwnedLambda(ownedLambda: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, ownedLambda, 0)
    }
    static func endParameter(builder: Builder): UInt32 {return builder.endObject()}
    static func createParameter(
        builder: Builder,
        base: UInt32,
        ownedFunc: UInt32,
        ownedLambda: UInt32
    ): UInt32 {
        PackageFormat_Parameter.startParameter(builder)
        PackageFormat_Parameter.addOwnedLambda(ownedLambda, builder)
        PackageFormat_Parameter.addOwnedFunc(ownedFunc, builder)
        PackageFormat_Parameter.addBase(base, builder)
        return PackageFormat_Parameter.endParameter(builder)
    }
}

public class PackageFormat_LocalVar <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ASSOCIATEDEXPR : UInt16 = 6
    let ISRETVAL : UInt16 = 8

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetAssociatedExpr(): UInt32 {
        return this.table.getUInt32Slot(ASSOCIATEDEXPR, 0)
    }
    func GetIsRetVal(): Bool {
        let o : UInt16 = this.table.offset(ISRETVAL)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startLocalVar(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addAssociatedExpr(associatedExpr: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, associatedExpr, 0)
    }
    static func addIsRetVal(isRetVal: Bool, builder: Builder) {
        builder.prependBoolSlot(2, isRetVal, false)
    }
    static func endLocalVar(builder: Builder): UInt32 {return builder.endObject()}
    static func createLocalVar(
        builder: Builder,
        base: UInt32,
        associatedExpr: UInt32,
        isRetVal: Bool
    ): UInt32 {
        PackageFormat_LocalVar.startLocalVar(builder)
        PackageFormat_LocalVar.addIsRetVal(isRetVal, builder)
        PackageFormat_LocalVar.addAssociatedExpr(associatedExpr, builder)
        PackageFormat_LocalVar.addBase(base, builder)
        return PackageFormat_LocalVar.endLocalVar(builder)
    }
}

public class PackageFormat_GlobalVar <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let RAWMANGLEDNAME : UInt16 = 6
    let SRCCODEIDENTIFIER : UInt16 = 8
    let PACKAGENAME : UInt16 = 10
    let DEFAULTINITVAL : UInt16 = 12
    let ASSOCIATEDINITFUNC : UInt16 = 14
    let DECLAREDPARENT : UInt16 = 16

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetRawMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(RAWMANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPackageName(): String {
        let o : UInt32 = UInt32(this.table.offset(PACKAGENAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetDefaultInitVal(): UInt32 {
        return this.table.getUInt32Slot(DEFAULTINITVAL, 0)
    }
    func GetAssociatedInitFunc(): UInt32 {
        return this.table.getUInt32Slot(ASSOCIATEDINITFUNC, 0)
    }
    func GetDeclaredParent(): UInt32 {
        return this.table.getUInt32Slot(DECLAREDPARENT, 0)
    }
    static func startGlobalVar(builder: Builder): Unit { builder.startObject(7) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addRawMangledName(rawMangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, rawMangledName, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, srcCodeIdentifier, 0)
    }
    static func addPackageName(packageName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, packageName, 0)
    }
    static func addDefaultInitVal(defaultInitVal: UInt32, builder: Builder) {
        builder.prependUInt32Slot(4, defaultInitVal, 0)
    }
    static func addAssociatedInitFunc(associatedInitFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(5, associatedInitFunc, 0)
    }
    static func addDeclaredParent(declaredParent: UInt32, builder: Builder) {
        builder.prependUInt32Slot(6, declaredParent, 0)
    }
    static func endGlobalVar(builder: Builder): UInt32 {return builder.endObject()}
    static func createGlobalVar(
        builder: Builder,
        base: UInt32,
        rawMangledName: UInt32,
        srcCodeIdentifier: UInt32,
        packageName: UInt32,
        defaultInitVal: UInt32,
        associatedInitFunc: UInt32,
        declaredParent: UInt32
    ): UInt32 {
        PackageFormat_GlobalVar.startGlobalVar(builder)
        PackageFormat_GlobalVar.addDeclaredParent(declaredParent, builder)
        PackageFormat_GlobalVar.addAssociatedInitFunc(associatedInitFunc, builder)
        PackageFormat_GlobalVar.addDefaultInitVal(defaultInitVal, builder)
        PackageFormat_GlobalVar.addPackageName(packageName, builder)
        PackageFormat_GlobalVar.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_GlobalVar.addRawMangledName(rawMangledName, builder)
        PackageFormat_GlobalVar.addBase(base, builder)
        return PackageFormat_GlobalVar.endGlobalVar(builder)
    }
}

public class PackageFormat_ImportedValue <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startImportedValue(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endImportedValue(builder: Builder): UInt32 {return builder.endObject()}
    static func createImportedValue(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_ImportedValue.startImportedValue(builder)
        PackageFormat_ImportedValue.addBase(base, builder)
        return PackageFormat_ImportedValue.endImportedValue(builder)
    }
}

public class PackageFormat_ImportedFunc <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SRCCODEIDENTIFIER : UInt16 = 6
    let RAWMANGLEDNAME : UInt16 = 8
    let PACKAGENAME : UInt16 = 10
    let DECLAREDPARENT : UInt16 = 12
    let GENERICDECL : UInt16 = 14
    let FUNCKIND : UInt16 = 16
    let ISFASTNATIVE : UInt16 = 18
    let ISCFFIWRAPPER : UInt16 = 20
    let ORIGINALLAMBDAFUNCTYPE : UInt16 = 22
    let ORIGINALLAMBDAGENERICTYPEPARAMS : UInt16 = 24
    let GENERICTYPEPARAMS : UInt16 = 26
    let PARAMDFTVALHOSTFUNC : UInt16 = 28
    let PARAMINFO : UInt16 = 30

    func GetBase(): Option<PackageFormat_ImportedValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_ImportedValue>
        } else {
            Some<PackageFormat_ImportedValue>(PackageFormat_ImportedValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetRawMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(RAWMANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPackageName(): String {
        let o : UInt32 = UInt32(this.table.offset(PACKAGENAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetDeclaredParent(): UInt32 {
        return this.table.getUInt32Slot(DECLAREDPARENT, 0)
    }
    func GetGenericDecl(): UInt32 {
        return this.table.getUInt32Slot(GENERICDECL, 0)
    }
    func GetFuncKind(): PackageFormat_FuncKind {
        let o : UInt32 = UInt32(this.table.offset(FUNCKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_FuncKind.FuncKind_DEFAULT
        } else {
            EnumValuesPackageFormat_FuncKind(this.table.getUInt8(off))
        }
    }
    func GetIsFastNative(): Bool {
        let o : UInt16 = this.table.offset(ISFASTNATIVE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetIsCFFIWrapper(): Bool {
        let o : UInt16 = this.table.offset(ISCFFIWRAPPER)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetOriginalLambdaFuncType(): UInt32 {
        return this.table.getUInt32Slot(ORIGINALLAMBDAFUNCTYPE, 0)
    }
    func GetOriginalLambdaGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(ORIGINALLAMBDAGENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(GENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetParamDftValHostFunc(): UInt32 {
        return this.table.getUInt32Slot(PARAMDFTVALHOSTFUNC, 0)
    }
    func GetParamInfo() : Array<Option<PackageFormat_AbstractMethodParam>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(PARAMINFO)
        var arr: Array<Option<PackageFormat_AbstractMethodParam>> = Array<Option<PackageFormat_AbstractMethodParam>>(LENGTH, repeat: None<PackageFormat_AbstractMethodParam>)
        let start: UInt32 = this.table.getVectorStartBySlot(PARAMINFO)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_AbstractMethodParam>
            } else {
                Some<PackageFormat_AbstractMethodParam>(PackageFormat_AbstractMethodParam(this.table.bytes, p))
            }
        }
        return arr
    }
    static func startImportedFunc(builder: Builder): Unit { builder.startObject(14) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, srcCodeIdentifier, 0)
    }
    static func addRawMangledName(rawMangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, rawMangledName, 0)
    }
    static func addPackageName(packageName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, packageName, 0)
    }
    static func addDeclaredParent(declaredParent: UInt32, builder: Builder) {
        builder.prependUInt32Slot(4, declaredParent, 0)
    }
    static func addGenericDecl(genericDecl: UInt32, builder: Builder) {
        builder.prependUInt32Slot(5, genericDecl, 0)
    }
    static func addFuncKind(funcKind: PackageFormat_FuncKind, builder: Builder) {
        builder.prependUInt8Slot(6, EnumPackageFormat_FuncKindValues(funcKind), 0)
    }
    static func addIsFastNative(isFastNative: Bool, builder: Builder) {
        builder.prependBoolSlot(7, isFastNative, false)
    }
    static func addIsCFFIWrapper(isCFFIWrapper: Bool, builder: Builder) {
        builder.prependBoolSlot(8, isCFFIWrapper, false)
    }
    static func addOriginalLambdaFuncType(originalLambdaFuncType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(9, originalLambdaFuncType, 0)
    }
    static func addOriginalLambdaGenericTypeParamsVector(originalLambdaGenericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(10, originalLambdaGenericTypeParams, 0)
    }
    static func addGenericTypeParamsVector(genericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(11, genericTypeParams, 0)
    }
    static func addParamDftValHostFunc(paramDftValHostFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(12, paramDftValHostFunc, 0)
    }
    static func addParamInfoVector(paramInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(13, paramInfo, 0)
    }
    static func endImportedFunc(builder: Builder): UInt32 {return builder.endObject()}
    static func createImportedFunc(
        builder: Builder,
        base: UInt32,
        srcCodeIdentifier: UInt32,
        rawMangledName: UInt32,
        packageName: UInt32,
        declaredParent: UInt32,
        genericDecl: UInt32,
        funcKind: PackageFormat_FuncKind,
        isFastNative: Bool,
        isCFFIWrapper: Bool,
        originalLambdaFuncType: UInt32,
        originalLambdaGenericTypeParams: UInt32,
        genericTypeParams: UInt32,
        paramDftValHostFunc: UInt32,
        paramInfo: UInt32
    ): UInt32 {
        PackageFormat_ImportedFunc.startImportedFunc(builder)
        PackageFormat_ImportedFunc.addParamInfoVector(paramInfo, builder)
        PackageFormat_ImportedFunc.addParamDftValHostFunc(paramDftValHostFunc, builder)
        PackageFormat_ImportedFunc.addGenericTypeParamsVector(genericTypeParams, builder)
        PackageFormat_ImportedFunc.addOriginalLambdaGenericTypeParamsVector(originalLambdaGenericTypeParams, builder)
        PackageFormat_ImportedFunc.addOriginalLambdaFuncType(originalLambdaFuncType, builder)
        PackageFormat_ImportedFunc.addIsCFFIWrapper(isCFFIWrapper, builder)
        PackageFormat_ImportedFunc.addIsFastNative(isFastNative, builder)
        PackageFormat_ImportedFunc.addFuncKind(funcKind, builder)
        PackageFormat_ImportedFunc.addGenericDecl(genericDecl, builder)
        PackageFormat_ImportedFunc.addDeclaredParent(declaredParent, builder)
        PackageFormat_ImportedFunc.addPackageName(packageName, builder)
        PackageFormat_ImportedFunc.addRawMangledName(rawMangledName, builder)
        PackageFormat_ImportedFunc.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_ImportedFunc.addBase(base, builder)
        return PackageFormat_ImportedFunc.endImportedFunc(builder)
    }
}

public class PackageFormat_ImportedVar <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let PACKAGENAME : UInt16 = 6
    let SRCCODEIDENTIFIER : UInt16 = 8
    let RAWMANGLEDNAME : UInt16 = 10

    func GetBase(): Option<PackageFormat_ImportedValue> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_ImportedValue>
        } else {
            Some<PackageFormat_ImportedValue>(PackageFormat_ImportedValue(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetPackageName(): String {
        let o : UInt32 = UInt32(this.table.offset(PACKAGENAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetRawMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(RAWMANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    static func startImportedVar(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addPackageName(packageName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, packageName, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, srcCodeIdentifier, 0)
    }
    static func addRawMangledName(rawMangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, rawMangledName, 0)
    }
    static func endImportedVar(builder: Builder): UInt32 {return builder.endObject()}
    static func createImportedVar(
        builder: Builder,
        base: UInt32,
        packageName: UInt32,
        srcCodeIdentifier: UInt32,
        rawMangledName: UInt32
    ): UInt32 {
        PackageFormat_ImportedVar.startImportedVar(builder)
        PackageFormat_ImportedVar.addRawMangledName(rawMangledName, builder)
        PackageFormat_ImportedVar.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_ImportedVar.addPackageName(packageName, builder)
        PackageFormat_ImportedVar.addBase(base, builder)
        return PackageFormat_ImportedVar.endImportedVar(builder)
    }
}

public class PackageFormat_Block <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let PARENTGROUP : UInt16 = 6
    let EXPRS : UInt16 = 8
    let PREDECESSORS : UInt16 = 10
    let ISLANDINGPADBLOCK : UInt16 = 12
    let EXCEPTIONCATCHLIST : UInt16 = 14

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetParentGroup(): UInt32 {
        return this.table.getUInt32Slot(PARENTGROUP, 0)
    }
    func GetExprs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXPRS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetPredecessors() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(PREDECESSORS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetIsLandingPadBlock(): Bool {
        let o : UInt16 = this.table.offset(ISLANDINGPADBLOCK)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetExceptionCatchList() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXCEPTIONCATCHLIST))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startBlock(builder: Builder): Unit { builder.startObject(6) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addParentGroup(parentGroup: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, parentGroup, 0)
    }
    static func addExprsVector(exprs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, exprs, 0)
    }
    static func addPredecessorsVector(predecessors: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, predecessors, 0)
    }
    static func addIsLandingPadBlock(isLandingPadBlock: Bool, builder: Builder) {
        builder.prependBoolSlot(4, isLandingPadBlock, false)
    }
    static func addExceptionCatchListVector(exceptionCatchList: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, exceptionCatchList, 0)
    }
    static func endBlock(builder: Builder): UInt32 {return builder.endObject()}
    static func createBlock(
        builder: Builder,
        base: UInt32,
        parentGroup: UInt32,
        exprs: UInt32,
        predecessors: UInt32,
        isLandingPadBlock: Bool,
        exceptionCatchList: UInt32
    ): UInt32 {
        PackageFormat_Block.startBlock(builder)
        PackageFormat_Block.addExceptionCatchListVector(exceptionCatchList, builder)
        PackageFormat_Block.addIsLandingPadBlock(isLandingPadBlock, builder)
        PackageFormat_Block.addPredecessorsVector(predecessors, builder)
        PackageFormat_Block.addExprsVector(exprs, builder)
        PackageFormat_Block.addParentGroup(parentGroup, builder)
        PackageFormat_Block.addBase(base, builder)
        return PackageFormat_Block.endBlock(builder)
    }
}

public class PackageFormat_BlockGroup <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ENTRYBLOCK : UInt16 = 6
    let BLOCKS : UInt16 = 8
    let OWNEDFUNC : UInt16 = 10
    let OWNEDEXPRESSION : UInt16 = 12

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetEntryBlock(): UInt32 {
        return this.table.getUInt32Slot(ENTRYBLOCK, 0)
    }
    func GetBlocks() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(BLOCKS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetOwnedFunc(): UInt32 {
        return this.table.getUInt32Slot(OWNEDFUNC, 0)
    }
    func GetOwnedExpression(): UInt32 {
        return this.table.getUInt32Slot(OWNEDEXPRESSION, 0)
    }
    static func startBlockGroup(builder: Builder): Unit { builder.startObject(5) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addEntryBlock(entryBlock: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, entryBlock, 0)
    }
    static func addBlocksVector(blocks: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, blocks, 0)
    }
    static func addOwnedFunc(ownedFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(3, ownedFunc, 0)
    }
    static func addOwnedExpression(ownedExpression: UInt32, builder: Builder) {
        builder.prependUInt32Slot(4, ownedExpression, 0)
    }
    static func endBlockGroup(builder: Builder): UInt32 {return builder.endObject()}
    static func createBlockGroup(
        builder: Builder,
        base: UInt32,
        entryBlock: UInt32,
        blocks: UInt32,
        ownedFunc: UInt32,
        ownedExpression: UInt32
    ): UInt32 {
        PackageFormat_BlockGroup.startBlockGroup(builder)
        PackageFormat_BlockGroup.addOwnedExpression(ownedExpression, builder)
        PackageFormat_BlockGroup.addOwnedFunc(ownedFunc, builder)
        PackageFormat_BlockGroup.addBlocksVector(blocks, builder)
        PackageFormat_BlockGroup.addEntryBlock(entryBlock, builder)
        PackageFormat_BlockGroup.addBase(base, builder)
        return PackageFormat_BlockGroup.endBlockGroup(builder)
    }
}

public class PackageFormat_Func <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SRCCODEIDENTIFIER : UInt16 = 6
    let RAWMANGLEDNAME : UInt16 = 8
    let PACKAGENAME : UInt16 = 10
    let DECLAREDPARENT : UInt16 = 12
    let GENERICDECL : UInt16 = 14
    let FUNCKIND : UInt16 = 16
    let ISFASTNATIVE : UInt16 = 18
    let ISCFFIWRAPPER : UInt16 = 20
    let ORIGINALLAMBDAFUNCTYPE : UInt16 = 22
    let ORIGINALLAMBDAGENERICTYPEPARAMS : UInt16 = 24
    let GENERICTYPEPARAMS : UInt16 = 26
    let PARAMDFTVALHOSTFUNC : UInt16 = 28
    let BODY : UInt16 = 30
    let PARAMS : UInt16 = 32
    let RETVAL : UInt16 = 34
    let PARENTNAME : UInt16 = 36
    let PROPLOC : UInt16 = 38
    let LOCALID : UInt16 = 40
    let BLOCKID : UInt16 = 42
    let BLOCKGROUPID : UInt16 = 44

    func GetBase(): Option<PackageFormat_Value> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Value>
        } else {
            Some<PackageFormat_Value>(PackageFormat_Value(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetRawMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(RAWMANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPackageName(): String {
        let o : UInt32 = UInt32(this.table.offset(PACKAGENAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetDeclaredParent(): UInt32 {
        return this.table.getUInt32Slot(DECLAREDPARENT, 0)
    }
    func GetGenericDecl(): UInt32 {
        return this.table.getUInt32Slot(GENERICDECL, 0)
    }
    func GetFuncKind(): PackageFormat_FuncKind {
        let o : UInt32 = UInt32(this.table.offset(FUNCKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_FuncKind.FuncKind_DEFAULT
        } else {
            EnumValuesPackageFormat_FuncKind(this.table.getUInt8(off))
        }
    }
    func GetIsFastNative(): Bool {
        let o : UInt16 = this.table.offset(ISFASTNATIVE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetIsCFFIWrapper(): Bool {
        let o : UInt16 = this.table.offset(ISCFFIWRAPPER)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetOriginalLambdaFuncType(): UInt32 {
        return this.table.getUInt32Slot(ORIGINALLAMBDAFUNCTYPE, 0)
    }
    func GetOriginalLambdaGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(ORIGINALLAMBDAGENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(GENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetParamDftValHostFunc(): UInt32 {
        return this.table.getUInt32Slot(PARAMDFTVALHOSTFUNC, 0)
    }
    func GetBody(): UInt32 {
        return this.table.getUInt32Slot(BODY, 0)
    }
    func GetParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(PARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetRetVal(): UInt32 {
        return this.table.getUInt32Slot(RETVAL, 0)
    }
    func GetParentName(): String {
        let o : UInt32 = UInt32(this.table.offset(PARENTNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPropLoc(): Option<PackageFormat_DebugLocation> {
        let o : UInt16 = this.table.offset(PROPLOC)
        return if (o == 0) {
            None<PackageFormat_DebugLocation>
        } else {
            Some<PackageFormat_DebugLocation>(PackageFormat_DebugLocation(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetLocalId(): UInt64 {
        return this.table.getUInt64Slot(LOCALID, 0)
    }
    func GetBlockId(): UInt64 {
        return this.table.getUInt64Slot(BLOCKID, 0)
    }
    func GetBlockGroupId(): UInt64 {
        return this.table.getUInt64Slot(BLOCKGROUPID, 0)
    }
    static func startFunc(builder: Builder): Unit { builder.startObject(21) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, srcCodeIdentifier, 0)
    }
    static func addRawMangledName(rawMangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, rawMangledName, 0)
    }
    static func addPackageName(packageName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, packageName, 0)
    }
    static func addDeclaredParent(declaredParent: UInt32, builder: Builder) {
        builder.prependUInt32Slot(4, declaredParent, 0)
    }
    static func addGenericDecl(genericDecl: UInt32, builder: Builder) {
        builder.prependUInt32Slot(5, genericDecl, 0)
    }
    static func addFuncKind(funcKind: PackageFormat_FuncKind, builder: Builder) {
        builder.prependUInt8Slot(6, EnumPackageFormat_FuncKindValues(funcKind), 0)
    }
    static func addIsFastNative(isFastNative: Bool, builder: Builder) {
        builder.prependBoolSlot(7, isFastNative, false)
    }
    static func addIsCFFIWrapper(isCFFIWrapper: Bool, builder: Builder) {
        builder.prependBoolSlot(8, isCFFIWrapper, false)
    }
    static func addOriginalLambdaFuncType(originalLambdaFuncType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(9, originalLambdaFuncType, 0)
    }
    static func addOriginalLambdaGenericTypeParamsVector(originalLambdaGenericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(10, originalLambdaGenericTypeParams, 0)
    }
    static func addGenericTypeParamsVector(genericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(11, genericTypeParams, 0)
    }
    static func addParamDftValHostFunc(paramDftValHostFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(12, paramDftValHostFunc, 0)
    }
    static func addBody(body: UInt32, builder: Builder) {
        builder.prependUInt32Slot(13, body, 0)
    }
    static func addParamsVector(params: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(14, params, 0)
    }
    static func addRetVal(retVal: UInt32, builder: Builder) {
        builder.prependUInt32Slot(15, retVal, 0)
    }
    static func addParentName(parentName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(16, parentName, 0)
    }
    static func addPropLoc(propLoc: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(17, propLoc, 0)
    }
    static func addLocalId(localId: UInt64, builder: Builder) {
        builder.prependUInt64Slot(18, localId, 0)
    }
    static func addBlockId(blockId: UInt64, builder: Builder) {
        builder.prependUInt64Slot(19, blockId, 0)
    }
    static func addBlockGroupId(blockGroupId: UInt64, builder: Builder) {
        builder.prependUInt64Slot(20, blockGroupId, 0)
    }
    static func endFunc(builder: Builder): UInt32 {return builder.endObject()}
    static func createFunc(
        builder: Builder,
        base: UInt32,
        srcCodeIdentifier: UInt32,
        rawMangledName: UInt32,
        packageName: UInt32,
        declaredParent: UInt32,
        genericDecl: UInt32,
        funcKind: PackageFormat_FuncKind,
        isFastNative: Bool,
        isCFFIWrapper: Bool,
        originalLambdaFuncType: UInt32,
        originalLambdaGenericTypeParams: UInt32,
        genericTypeParams: UInt32,
        paramDftValHostFunc: UInt32,
        body: UInt32,
        params: UInt32,
        retVal: UInt32,
        parentName: UInt32,
        propLoc: UInt32,
        localId: UInt64,
        blockId: UInt64,
        blockGroupId: UInt64
    ): UInt32 {
        PackageFormat_Func.startFunc(builder)
        PackageFormat_Func.addBlockGroupId(blockGroupId, builder)
        PackageFormat_Func.addBlockId(blockId, builder)
        PackageFormat_Func.addLocalId(localId, builder)
        PackageFormat_Func.addPropLoc(propLoc, builder)
        PackageFormat_Func.addParentName(parentName, builder)
        PackageFormat_Func.addRetVal(retVal, builder)
        PackageFormat_Func.addParamsVector(params, builder)
        PackageFormat_Func.addBody(body, builder)
        PackageFormat_Func.addParamDftValHostFunc(paramDftValHostFunc, builder)
        PackageFormat_Func.addGenericTypeParamsVector(genericTypeParams, builder)
        PackageFormat_Func.addOriginalLambdaGenericTypeParamsVector(originalLambdaGenericTypeParams, builder)
        PackageFormat_Func.addOriginalLambdaFuncType(originalLambdaFuncType, builder)
        PackageFormat_Func.addIsCFFIWrapper(isCFFIWrapper, builder)
        PackageFormat_Func.addIsFastNative(isFastNative, builder)
        PackageFormat_Func.addFuncKind(funcKind, builder)
        PackageFormat_Func.addGenericDecl(genericDecl, builder)
        PackageFormat_Func.addDeclaredParent(declaredParent, builder)
        PackageFormat_Func.addPackageName(packageName, builder)
        PackageFormat_Func.addRawMangledName(rawMangledName, builder)
        PackageFormat_Func.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_Func.addBase(base, builder)
        return PackageFormat_Func.endFunc(builder)
    }
}

public class PackageFormat_AnnoInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let MANGLEDNAME : UInt16 = 4

    func GetMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(MANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    static func startAnnoInfo(builder: Builder): Unit { builder.startObject(1) }
    static func addMangledName(mangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, mangledName, 0)
    }
    static func endAnnoInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createAnnoInfo(
        builder: Builder,
        mangledName: UInt32
    ): UInt32 {
        PackageFormat_AnnoInfo.startAnnoInfo(builder)
        PackageFormat_AnnoInfo.addMangledName(mangledName, builder)
        return PackageFormat_AnnoInfo.endAnnoInfo(builder)
    }
}

public class PackageFormat_MemberVarInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let NAME : UInt16 = 4
    let RAWMANGLEDNAME : UInt16 = 6
    let TYPE : UInt16 = 8
    let ATTRIBUTES : UInt16 = 10
    let LOC : UInt16 = 12
    let ANNOINFO : UInt16 = 14
    let INITIALIZERFUNC : UInt16 = 16
    let OUTERDEF : UInt16 = 18

    func GetName(): String {
        let o : UInt32 = UInt32(this.table.offset(NAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetRawMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(RAWMANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetType(): UInt32 {
        return this.table.getUInt32Slot(TYPE, 0)
    }
    func GetAttributes(): UInt64 {
        return this.table.getUInt64Slot(ATTRIBUTES, 0)
    }
    func GetLoc(): Option<PackageFormat_DebugLocation> {
        let o : UInt16 = this.table.offset(LOC)
        return if (o == 0) {
            None<PackageFormat_DebugLocation>
        } else {
            Some<PackageFormat_DebugLocation>(PackageFormat_DebugLocation(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetAnnoInfo(): Option<PackageFormat_AnnoInfo> {
        let o : UInt16 = this.table.offset(ANNOINFO)
        return if (o == 0) {
            None<PackageFormat_AnnoInfo>
        } else {
            Some<PackageFormat_AnnoInfo>(PackageFormat_AnnoInfo(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInitializerFunc(): UInt32 {
        return this.table.getUInt32Slot(INITIALIZERFUNC, 0)
    }
    func GetOuterDef(): UInt32 {
        return this.table.getUInt32Slot(OUTERDEF, 0)
    }
    static func startMemberVarInfo(builder: Builder): Unit { builder.startObject(8) }
    static func addName(name: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, name, 0)
    }
    static func addRawMangledName(rawMangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, rawMangledName, 0)
    }
    static func addType(type_: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, type_, 0)
    }
    static func addAttributes(attributes: UInt64, builder: Builder) {
        builder.prependUInt64Slot(3, attributes, 0)
    }
    static func addLoc(loc: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, loc, 0)
    }
    static func addAnnoInfo(annoInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, annoInfo, 0)
    }
    static func addInitializerFunc(initializerFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(6, initializerFunc, 0)
    }
    static func addOuterDef(outerDef: UInt32, builder: Builder) {
        builder.prependUInt32Slot(7, outerDef, 0)
    }
    static func endMemberVarInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createMemberVarInfo(
        builder: Builder,
        name: UInt32,
        rawMangledName: UInt32,
        type_: UInt32,
        attributes: UInt64,
        loc: UInt32,
        annoInfo: UInt32,
        initializerFunc: UInt32,
        outerDef: UInt32
    ): UInt32 {
        PackageFormat_MemberVarInfo.startMemberVarInfo(builder)
        PackageFormat_MemberVarInfo.addOuterDef(outerDef, builder)
        PackageFormat_MemberVarInfo.addInitializerFunc(initializerFunc, builder)
        PackageFormat_MemberVarInfo.addAnnoInfo(annoInfo, builder)
        PackageFormat_MemberVarInfo.addLoc(loc, builder)
        PackageFormat_MemberVarInfo.addAttributes(attributes, builder)
        PackageFormat_MemberVarInfo.addType(type_, builder)
        PackageFormat_MemberVarInfo.addRawMangledName(rawMangledName, builder)
        PackageFormat_MemberVarInfo.addName(name, builder)
        return PackageFormat_MemberVarInfo.endMemberVarInfo(builder)
    }
}

public class PackageFormat_VirtualMethodInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let FUNCNAME : UInt16 = 4
    let SIGTYPE : UInt16 = 6
    let METHODGENERICTYPEPARAMS : UInt16 = 8
    let INSTANCE : UInt16 = 10
    let ATTRIBUTES : UInt16 = 12
    let ORIGINALTYPE : UInt16 = 14
    let PARENTTYPE : UInt16 = 16
    let RETURNTYPE : UInt16 = 18

    func GetFuncName(): String {
        let o : UInt32 = UInt32(this.table.offset(FUNCNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetSigType(): UInt32 {
        return this.table.getUInt32Slot(SIGTYPE, 0)
    }
    func GetMethodGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(METHODGENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetInstance(): UInt32 {
        return this.table.getUInt32Slot(INSTANCE, 0)
    }
    func GetAttributes(): UInt64 {
        return this.table.getUInt64Slot(ATTRIBUTES, 0)
    }
    func GetOriginalType(): UInt32 {
        return this.table.getUInt32Slot(ORIGINALTYPE, 0)
    }
    func GetParentType(): UInt32 {
        return this.table.getUInt32Slot(PARENTTYPE, 0)
    }
    func GetReturnType(): UInt32 {
        return this.table.getUInt32Slot(RETURNTYPE, 0)
    }
    static func startVirtualMethodInfo(builder: Builder): Unit { builder.startObject(8) }
    static func addFuncName(funcName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, funcName, 0)
    }
    static func addSigType(sigType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, sigType, 0)
    }
    static func addMethodGenericTypeParamsVector(methodGenericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, methodGenericTypeParams, 0)
    }
    static func addInstance(instance: UInt32, builder: Builder) {
        builder.prependUInt32Slot(3, instance, 0)
    }
    static func addAttributes(attributes: UInt64, builder: Builder) {
        builder.prependUInt64Slot(4, attributes, 0)
    }
    static func addOriginalType(originalType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(5, originalType, 0)
    }
    static func addParentType(parentType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(6, parentType, 0)
    }
    static func addReturnType(returnType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(7, returnType, 0)
    }
    static func endVirtualMethodInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createVirtualMethodInfo(
        builder: Builder,
        funcName: UInt32,
        sigType: UInt32,
        methodGenericTypeParams: UInt32,
        instance: UInt32,
        attributes: UInt64,
        originalType: UInt32,
        parentType: UInt32,
        returnType: UInt32
    ): UInt32 {
        PackageFormat_VirtualMethodInfo.startVirtualMethodInfo(builder)
        PackageFormat_VirtualMethodInfo.addReturnType(returnType, builder)
        PackageFormat_VirtualMethodInfo.addParentType(parentType, builder)
        PackageFormat_VirtualMethodInfo.addOriginalType(originalType, builder)
        PackageFormat_VirtualMethodInfo.addAttributes(attributes, builder)
        PackageFormat_VirtualMethodInfo.addInstance(instance, builder)
        PackageFormat_VirtualMethodInfo.addMethodGenericTypeParamsVector(methodGenericTypeParams, builder)
        PackageFormat_VirtualMethodInfo.addSigType(sigType, builder)
        PackageFormat_VirtualMethodInfo.addFuncName(funcName, builder)
        return PackageFormat_VirtualMethodInfo.endVirtualMethodInfo(builder)
    }
}

public class PackageFormat_VTableInType <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let SRCPARENTTYPE : UInt16 = 4
    let VIRTUALMETHODS : UInt16 = 6

    func GetSrcParentType(): UInt32 {
        return this.table.getUInt32Slot(SRCPARENTTYPE, 0)
    }
    func GetVirtualMethods() : Array<Option<PackageFormat_VirtualMethodInfo>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(VIRTUALMETHODS)
        var arr: Array<Option<PackageFormat_VirtualMethodInfo>> = Array<Option<PackageFormat_VirtualMethodInfo>>(LENGTH, repeat: None<PackageFormat_VirtualMethodInfo>)
        let start: UInt32 = this.table.getVectorStartBySlot(VIRTUALMETHODS)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_VirtualMethodInfo>
            } else {
                Some<PackageFormat_VirtualMethodInfo>(PackageFormat_VirtualMethodInfo(this.table.bytes, p))
            }
        }
        return arr
    }
    static func startVTableInType(builder: Builder): Unit { builder.startObject(2) }
    static func addSrcParentType(srcParentType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(0, srcParentType, 0)
    }
    static func addVirtualMethodsVector(virtualMethods: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, virtualMethods, 0)
    }
    static func endVTableInType(builder: Builder): UInt32 {return builder.endObject()}
    static func createVTableInType(
        builder: Builder,
        srcParentType: UInt32,
        virtualMethods: UInt32
    ): UInt32 {
        PackageFormat_VTableInType.startVTableInType(builder)
        PackageFormat_VTableInType.addVirtualMethodsVector(virtualMethods, builder)
        PackageFormat_VTableInType.addSrcParentType(srcParentType, builder)
        return PackageFormat_VTableInType.endVTableInType(builder)
    }
}

public class PackageFormat_CustomTypeDef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let KIND : UInt16 = 6
    let CUSTOMTYPEDEFID : UInt16 = 8
    let SRCCODEIDENTIFIER : UInt16 = 10
    let IDENTIFIER : UInt16 = 12
    let PACKAGENAME : UInt16 = 14
    let TYPE : UInt16 = 16
    let GENERICDECL : UInt16 = 18
    let METHODS : UInt16 = 20
    let IMPLEMENTEDINTERFACES : UInt16 = 22
    let INSTANCEMEMBERVARS : UInt16 = 24
    let STATICMEMBERVARS : UInt16 = 26
    let ATTRIBUTES : UInt16 = 28
    let ANNOINFO : UInt16 = 30
    let VTABLE : UInt16 = 32
    let EXTENDS : UInt16 = 34
    let VARINITIALIZATIONFUNC : UInt16 = 36

    func GetBase(): Option<PackageFormat_Base> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Base>
        } else {
            Some<PackageFormat_Base>(PackageFormat_Base(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetKind(): PackageFormat_CustomDefKind {
        let o : UInt32 = UInt32(this.table.offset(KIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_CustomDefKind.CustomDefKind_STRUCT
        } else {
            EnumValuesPackageFormat_CustomDefKind(this.table.getUInt8(off))
        }
    }
    func GetCustomTypeDefID(): UInt32 {
        return this.table.getUInt32Slot(CUSTOMTYPEDEFID, 0)
    }
    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(IDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPackageName(): String {
        let o : UInt32 = UInt32(this.table.offset(PACKAGENAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetType(): UInt32 {
        return this.table.getUInt32Slot(TYPE, 0)
    }
    func GetGenericDecl(): UInt32 {
        return this.table.getUInt32Slot(GENERICDECL, 0)
    }
    func GetMethods() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(METHODS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetImplementedInterfaces() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(IMPLEMENTEDINTERFACES))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetInstanceMemberVars() : Array<Option<PackageFormat_MemberVarInfo>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(INSTANCEMEMBERVARS)
        var arr: Array<Option<PackageFormat_MemberVarInfo>> = Array<Option<PackageFormat_MemberVarInfo>>(LENGTH, repeat: None<PackageFormat_MemberVarInfo>)
        let start: UInt32 = this.table.getVectorStartBySlot(INSTANCEMEMBERVARS)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_MemberVarInfo>
            } else {
                Some<PackageFormat_MemberVarInfo>(PackageFormat_MemberVarInfo(this.table.bytes, p))
            }
        }
        return arr
    }
    func GetStaticMemberVars() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(STATICMEMBERVARS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetAttributes(): UInt64 {
        return this.table.getUInt64Slot(ATTRIBUTES, 0)
    }
    func GetAnnoInfo(): Option<PackageFormat_AnnoInfo> {
        let o : UInt16 = this.table.offset(ANNOINFO)
        return if (o == 0) {
            None<PackageFormat_AnnoInfo>
        } else {
            Some<PackageFormat_AnnoInfo>(PackageFormat_AnnoInfo(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetVtable() : Array<Option<PackageFormat_VTableInType>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(VTABLE)
        var arr: Array<Option<PackageFormat_VTableInType>> = Array<Option<PackageFormat_VTableInType>>(LENGTH, repeat: None<PackageFormat_VTableInType>)
        let start: UInt32 = this.table.getVectorStartBySlot(VTABLE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_VTableInType>
            } else {
                Some<PackageFormat_VTableInType>(PackageFormat_VTableInType(this.table.bytes, p))
            }
        }
        return arr
    }
    func GetExtends() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(EXTENDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetVarInitializationFunc(): UInt32 {
        return this.table.getUInt32Slot(VARINITIALIZATIONFUNC, 0)
    }
    static func startCustomTypeDef(builder: Builder): Unit { builder.startObject(17) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addKind(kind: PackageFormat_CustomDefKind, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_CustomDefKindValues(kind), 0)
    }
    static func addCustomTypeDefID(customTypeDefID: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, customTypeDefID, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, srcCodeIdentifier, 0)
    }
    static func addIdentifier(identifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, identifier, 0)
    }
    static func addPackageName(packageName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, packageName, 0)
    }
    static func addType(type_: UInt32, builder: Builder) {
        builder.prependUInt32Slot(6, type_, 0)
    }
    static func addGenericDecl(genericDecl: UInt32, builder: Builder) {
        builder.prependUInt32Slot(7, genericDecl, 0)
    }
    static func addMethodsVector(methods: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(8, methods, 0)
    }
    static func addImplementedInterfacesVector(implementedInterfaces: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(9, implementedInterfaces, 0)
    }
    static func addInstanceMemberVarsVector(instanceMemberVars: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(10, instanceMemberVars, 0)
    }
    static func addStaticMemberVarsVector(staticMemberVars: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(11, staticMemberVars, 0)
    }
    static func addAttributes(attributes: UInt64, builder: Builder) {
        builder.prependUInt64Slot(12, attributes, 0)
    }
    static func addAnnoInfo(annoInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(13, annoInfo, 0)
    }
    static func addVtableVector(vtable: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(14, vtable, 0)
    }
    static func addExtendsVector(extends: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(15, extends, 0)
    }
    static func addVarInitializationFunc(varInitializationFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(16, varInitializationFunc, 0)
    }
    static func endCustomTypeDef(builder: Builder): UInt32 {return builder.endObject()}
    static func createCustomTypeDef(
        builder: Builder,
        base: UInt32,
        kind: PackageFormat_CustomDefKind,
        customTypeDefID: UInt32,
        srcCodeIdentifier: UInt32,
        identifier: UInt32,
        packageName: UInt32,
        type_: UInt32,
        genericDecl: UInt32,
        methods: UInt32,
        implementedInterfaces: UInt32,
        instanceMemberVars: UInt32,
        staticMemberVars: UInt32,
        attributes: UInt64,
        annoInfo: UInt32,
        vtable: UInt32,
        extends: UInt32,
        varInitializationFunc: UInt32
    ): UInt32 {
        PackageFormat_CustomTypeDef.startCustomTypeDef(builder)
        PackageFormat_CustomTypeDef.addVarInitializationFunc(varInitializationFunc, builder)
        PackageFormat_CustomTypeDef.addExtendsVector(extends, builder)
        PackageFormat_CustomTypeDef.addVtableVector(vtable, builder)
        PackageFormat_CustomTypeDef.addAnnoInfo(annoInfo, builder)
        PackageFormat_CustomTypeDef.addAttributes(attributes, builder)
        PackageFormat_CustomTypeDef.addStaticMemberVarsVector(staticMemberVars, builder)
        PackageFormat_CustomTypeDef.addInstanceMemberVarsVector(instanceMemberVars, builder)
        PackageFormat_CustomTypeDef.addImplementedInterfacesVector(implementedInterfaces, builder)
        PackageFormat_CustomTypeDef.addMethodsVector(methods, builder)
        PackageFormat_CustomTypeDef.addGenericDecl(genericDecl, builder)
        PackageFormat_CustomTypeDef.addType(type_, builder)
        PackageFormat_CustomTypeDef.addPackageName(packageName, builder)
        PackageFormat_CustomTypeDef.addIdentifier(identifier, builder)
        PackageFormat_CustomTypeDef.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_CustomTypeDef.addCustomTypeDefID(customTypeDefID, builder)
        PackageFormat_CustomTypeDef.addKind(kind, builder)
        PackageFormat_CustomTypeDef.addBase(base, builder)
        return PackageFormat_CustomTypeDef.endCustomTypeDef(builder)
    }
}

public class PackageFormat_EnumCtorInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let IDENTIFIER : UInt16 = 4
    let MANGLEDNAME : UInt16 = 6
    let FUNCTYPE : UInt16 = 8

    func GetIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(IDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(MANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetFuncType(): UInt32 {
        return this.table.getUInt32Slot(FUNCTYPE, 0)
    }
    static func startEnumCtorInfo(builder: Builder): Unit { builder.startObject(3) }
    static func addIdentifier(identifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, identifier, 0)
    }
    static func addMangledName(mangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, mangledName, 0)
    }
    static func addFuncType(funcType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, funcType, 0)
    }
    static func endEnumCtorInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createEnumCtorInfo(
        builder: Builder,
        identifier: UInt32,
        mangledName: UInt32,
        funcType: UInt32
    ): UInt32 {
        PackageFormat_EnumCtorInfo.startEnumCtorInfo(builder)
        PackageFormat_EnumCtorInfo.addFuncType(funcType, builder)
        PackageFormat_EnumCtorInfo.addMangledName(mangledName, builder)
        PackageFormat_EnumCtorInfo.addIdentifier(identifier, builder)
        return PackageFormat_EnumCtorInfo.endEnumCtorInfo(builder)
    }
}

public class PackageFormat_EnumDef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let CTORS : UInt16 = 6
    let NONEXHAUSTIVE : UInt16 = 8

    func GetBase(): Option<PackageFormat_CustomTypeDef> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomTypeDef>
        } else {
            Some<PackageFormat_CustomTypeDef>(PackageFormat_CustomTypeDef(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetCtors() : Array<Option<PackageFormat_EnumCtorInfo>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(CTORS)
        var arr: Array<Option<PackageFormat_EnumCtorInfo>> = Array<Option<PackageFormat_EnumCtorInfo>>(LENGTH, repeat: None<PackageFormat_EnumCtorInfo>)
        let start: UInt32 = this.table.getVectorStartBySlot(CTORS)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_EnumCtorInfo>
            } else {
                Some<PackageFormat_EnumCtorInfo>(PackageFormat_EnumCtorInfo(this.table.bytes, p))
            }
        }
        return arr
    }
    func GetNonExhaustive(): Bool {
        let o : UInt16 = this.table.offset(NONEXHAUSTIVE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startEnumDef(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addCtorsVector(ctors: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, ctors, 0)
    }
    static func addNonExhaustive(nonExhaustive: Bool, builder: Builder) {
        builder.prependBoolSlot(2, nonExhaustive, false)
    }
    static func endEnumDef(builder: Builder): UInt32 {return builder.endObject()}
    static func createEnumDef(
        builder: Builder,
        base: UInt32,
        ctors: UInt32,
        nonExhaustive: Bool
    ): UInt32 {
        PackageFormat_EnumDef.startEnumDef(builder)
        PackageFormat_EnumDef.addNonExhaustive(nonExhaustive, builder)
        PackageFormat_EnumDef.addCtorsVector(ctors, builder)
        PackageFormat_EnumDef.addBase(base, builder)
        return PackageFormat_EnumDef.endEnumDef(builder)
    }
}

public class PackageFormat_StructDef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ISCSTRUCT : UInt16 = 6

    func GetBase(): Option<PackageFormat_CustomTypeDef> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomTypeDef>
        } else {
            Some<PackageFormat_CustomTypeDef>(PackageFormat_CustomTypeDef(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIsCStruct(): Bool {
        let o : UInt16 = this.table.offset(ISCSTRUCT)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startStructDef(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIsCStruct(isCStruct: Bool, builder: Builder) {
        builder.prependBoolSlot(1, isCStruct, false)
    }
    static func endStructDef(builder: Builder): UInt32 {return builder.endObject()}
    static func createStructDef(
        builder: Builder,
        base: UInt32,
        isCStruct: Bool
    ): UInt32 {
        PackageFormat_StructDef.startStructDef(builder)
        PackageFormat_StructDef.addIsCStruct(isCStruct, builder)
        PackageFormat_StructDef.addBase(base, builder)
        return PackageFormat_StructDef.endStructDef(builder)
    }
}

public class PackageFormat_ExtendDef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXTENDEDTYPE : UInt16 = 6
    let GENERICPARAMS : UInt16 = 8

    func GetBase(): Option<PackageFormat_CustomTypeDef> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomTypeDef>
        } else {
            Some<PackageFormat_CustomTypeDef>(PackageFormat_CustomTypeDef(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExtendedType(): UInt32 {
        return this.table.getUInt32Slot(EXTENDEDTYPE, 0)
    }
    func GetGenericParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(GENERICPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startExtendDef(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExtendedType(extendedType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, extendedType, 0)
    }
    static func addGenericParamsVector(genericParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, genericParams, 0)
    }
    static func endExtendDef(builder: Builder): UInt32 {return builder.endObject()}
    static func createExtendDef(
        builder: Builder,
        base: UInt32,
        extendedType: UInt32,
        genericParams: UInt32
    ): UInt32 {
        PackageFormat_ExtendDef.startExtendDef(builder)
        PackageFormat_ExtendDef.addGenericParamsVector(genericParams, builder)
        PackageFormat_ExtendDef.addExtendedType(extendedType, builder)
        PackageFormat_ExtendDef.addBase(base, builder)
        return PackageFormat_ExtendDef.endExtendDef(builder)
    }
}

public class PackageFormat_AbstractMethodParam <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let PARAMNAME : UInt16 = 4
    let PARAMTYPE : UInt16 = 6
    let ANNOINFO : UInt16 = 8

    func GetParamName(): String {
        let o : UInt32 = UInt32(this.table.offset(PARAMNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetParamType(): UInt32 {
        return this.table.getUInt32Slot(PARAMTYPE, 0)
    }
    func GetAnnoInfo(): Option<PackageFormat_AnnoInfo> {
        let o : UInt16 = this.table.offset(ANNOINFO)
        return if (o == 0) {
            None<PackageFormat_AnnoInfo>
        } else {
            Some<PackageFormat_AnnoInfo>(PackageFormat_AnnoInfo(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startAbstractMethodParam(builder: Builder): Unit { builder.startObject(3) }
    static func addParamName(paramName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, paramName, 0)
    }
    static func addParamType(paramType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, paramType, 0)
    }
    static func addAnnoInfo(annoInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, annoInfo, 0)
    }
    static func endAbstractMethodParam(builder: Builder): UInt32 {return builder.endObject()}
    static func createAbstractMethodParam(
        builder: Builder,
        paramName: UInt32,
        paramType: UInt32,
        annoInfo: UInt32
    ): UInt32 {
        PackageFormat_AbstractMethodParam.startAbstractMethodParam(builder)
        PackageFormat_AbstractMethodParam.addAnnoInfo(annoInfo, builder)
        PackageFormat_AbstractMethodParam.addParamType(paramType, builder)
        PackageFormat_AbstractMethodParam.addParamName(paramName, builder)
        return PackageFormat_AbstractMethodParam.endAbstractMethodParam(builder)
    }
}

public class PackageFormat_AbstractMethodInfo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let METHODNAME : UInt16 = 4
    let MANGLEDNAME : UInt16 = 6
    let METHODTYPE : UInt16 = 8
    let PARAMSINFO : UInt16 = 10
    let ATTRIBUTES : UInt16 = 12
    let ANNOINFO : UInt16 = 14
    let METHODGENERICTYPEPARAMS : UInt16 = 16
    let HASBODY : UInt16 = 18
    let PARENT : UInt16 = 20

    func GetMethodName(): String {
        let o : UInt32 = UInt32(this.table.offset(METHODNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetMangledName(): String {
        let o : UInt32 = UInt32(this.table.offset(MANGLEDNAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetMethodType(): UInt32 {
        return this.table.getUInt32Slot(METHODTYPE, 0)
    }
    func GetParamsInfo() : Array<Option<PackageFormat_AbstractMethodParam>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(PARAMSINFO)
        var arr: Array<Option<PackageFormat_AbstractMethodParam>> = Array<Option<PackageFormat_AbstractMethodParam>>(LENGTH, repeat: None<PackageFormat_AbstractMethodParam>)
        let start: UInt32 = this.table.getVectorStartBySlot(PARAMSINFO)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_AbstractMethodParam>
            } else {
                Some<PackageFormat_AbstractMethodParam>(PackageFormat_AbstractMethodParam(this.table.bytes, p))
            }
        }
        return arr
    }
    func GetAttributes(): UInt64 {
        return this.table.getUInt64Slot(ATTRIBUTES, 0)
    }
    func GetAnnoInfo(): Option<PackageFormat_AnnoInfo> {
        let o : UInt16 = this.table.offset(ANNOINFO)
        return if (o == 0) {
            None<PackageFormat_AnnoInfo>
        } else {
            Some<PackageFormat_AnnoInfo>(PackageFormat_AnnoInfo(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetMethodGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(METHODGENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetHasBody(): Bool {
        let o : UInt16 = this.table.offset(HASBODY)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetParent(): UInt32 {
        return this.table.getUInt32Slot(PARENT, 0)
    }
    static func startAbstractMethodInfo(builder: Builder): Unit { builder.startObject(9) }
    static func addMethodName(methodName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, methodName, 0)
    }
    static func addMangledName(mangledName: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, mangledName, 0)
    }
    static func addMethodType(methodType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, methodType, 0)
    }
    static func addParamsInfoVector(paramsInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, paramsInfo, 0)
    }
    static func addAttributes(attributes: UInt64, builder: Builder) {
        builder.prependUInt64Slot(4, attributes, 0)
    }
    static func addAnnoInfo(annoInfo: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, annoInfo, 0)
    }
    static func addMethodGenericTypeParamsVector(methodGenericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(6, methodGenericTypeParams, 0)
    }
    static func addHasBody(hasBody: Bool, builder: Builder) {
        builder.prependBoolSlot(7, hasBody, false)
    }
    static func addParent(parent: UInt32, builder: Builder) {
        builder.prependUInt32Slot(8, parent, 0)
    }
    static func endAbstractMethodInfo(builder: Builder): UInt32 {return builder.endObject()}
    static func createAbstractMethodInfo(
        builder: Builder,
        methodName: UInt32,
        mangledName: UInt32,
        methodType: UInt32,
        paramsInfo: UInt32,
        attributes: UInt64,
        annoInfo: UInt32,
        methodGenericTypeParams: UInt32,
        hasBody: Bool,
        parent: UInt32
    ): UInt32 {
        PackageFormat_AbstractMethodInfo.startAbstractMethodInfo(builder)
        PackageFormat_AbstractMethodInfo.addParent(parent, builder)
        PackageFormat_AbstractMethodInfo.addHasBody(hasBody, builder)
        PackageFormat_AbstractMethodInfo.addMethodGenericTypeParamsVector(methodGenericTypeParams, builder)
        PackageFormat_AbstractMethodInfo.addAnnoInfo(annoInfo, builder)
        PackageFormat_AbstractMethodInfo.addAttributes(attributes, builder)
        PackageFormat_AbstractMethodInfo.addParamsInfoVector(paramsInfo, builder)
        PackageFormat_AbstractMethodInfo.addMethodType(methodType, builder)
        PackageFormat_AbstractMethodInfo.addMangledName(mangledName, builder)
        PackageFormat_AbstractMethodInfo.addMethodName(methodName, builder)
        return PackageFormat_AbstractMethodInfo.endAbstractMethodInfo(builder)
    }
}

public class PackageFormat_ClassDef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let KIND : UInt16 = 6
    let ISANNOTATION : UInt16 = 8
    let SUPERCLASS : UInt16 = 10
    let ABSTRACTMETHODS : UInt16 = 12
    let ALLMETHODMANGLEDNAMES : UInt16 = 14

    func GetBase(): Option<PackageFormat_CustomTypeDef> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_CustomTypeDef>
        } else {
            Some<PackageFormat_CustomTypeDef>(PackageFormat_CustomTypeDef(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetKind(): PackageFormat_ClassDefKind {
        let o : UInt32 = UInt32(this.table.offset(KIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_ClassDefKind.ClassDefKind_CLASS
        } else {
            EnumValuesPackageFormat_ClassDefKind(this.table.getInt16(off))
        }
    }
    func GetIsAnnotation(): Bool {
        let o : UInt16 = this.table.offset(ISANNOTATION)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetSuperClass(): UInt32 {
        return this.table.getUInt32Slot(SUPERCLASS, 0)
    }
    func GetAbstractMethods() : Array<Option<PackageFormat_AbstractMethodInfo>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(ABSTRACTMETHODS)
        var arr: Array<Option<PackageFormat_AbstractMethodInfo>> = Array<Option<PackageFormat_AbstractMethodInfo>>(LENGTH, repeat: None<PackageFormat_AbstractMethodInfo>)
        let start: UInt32 = this.table.getVectorStartBySlot(ABSTRACTMETHODS)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<PackageFormat_AbstractMethodInfo>
            } else {
                Some<PackageFormat_AbstractMethodInfo>(PackageFormat_AbstractMethodInfo(this.table.bytes, p))
            }
        }
        return arr
    }
    func GetAllMethodMangledNames() : Array<Option<String>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(ALLMETHODMANGLEDNAMES)
        var arr: Array<Option<String>> = Array<Option<String>>(LENGTH, repeat: None<String>)
        let start: UInt32 = this.table.getVectorStartBySlot(ALLMETHODMANGLEDNAMES)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<String>
            } else {
                Some<String>(this.table.getString(p))
            }
        }
        return arr
    }
    static func startClassDef(builder: Builder): Unit { builder.startObject(6) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addKind(kind: PackageFormat_ClassDefKind, builder: Builder) {
        builder.prependInt16Slot(1, EnumPackageFormat_ClassDefKindValues(kind), 0)
    }
    static func addIsAnnotation(isAnnotation: Bool, builder: Builder) {
        builder.prependBoolSlot(2, isAnnotation, false)
    }
    static func addSuperClass(superClass: UInt32, builder: Builder) {
        builder.prependUInt32Slot(3, superClass, 0)
    }
    static func addAbstractMethodsVector(abstractMethods: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, abstractMethods, 0)
    }
    static func addAllMethodMangledNamesVector(allMethodMangledNames: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, allMethodMangledNames, 0)
    }
    static func endClassDef(builder: Builder): UInt32 {return builder.endObject()}
    static func createClassDef(
        builder: Builder,
        base: UInt32,
        kind: PackageFormat_ClassDefKind,
        isAnnotation: Bool,
        superClass: UInt32,
        abstractMethods: UInt32,
        allMethodMangledNames: UInt32
    ): UInt32 {
        PackageFormat_ClassDef.startClassDef(builder)
        PackageFormat_ClassDef.addAllMethodMangledNamesVector(allMethodMangledNames, builder)
        PackageFormat_ClassDef.addAbstractMethodsVector(abstractMethods, builder)
        PackageFormat_ClassDef.addSuperClass(superClass, builder)
        PackageFormat_ClassDef.addIsAnnotation(isAnnotation, builder)
        PackageFormat_ClassDef.addKind(kind, builder)
        PackageFormat_ClassDef.addBase(base, builder)
        return PackageFormat_ClassDef.endClassDef(builder)
    }
}

public class PackageFormat_Expression <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let KIND : UInt16 = 6
    let EXPRESSIONID : UInt16 = 8
    let OPERANDS : UInt16 = 10
    let BLOCKGROUPS : UInt16 = 12
    let PARENTBLOCK : UInt16 = 14
    let RESULTLOCALVAR : UInt16 = 16
    let RESULTTY : UInt16 = 18

    func GetBase(): Option<PackageFormat_Base> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Base>
        } else {
            Some<PackageFormat_Base>(PackageFormat_Base(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetKind(): PackageFormat_CHIRExprKind {
        let o : UInt32 = UInt32(this.table.offset(KIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_CHIRExprKind.CHIRExprKind_INVALID
        } else {
            EnumValuesPackageFormat_CHIRExprKind(this.table.getUInt8(off))
        }
    }
    func GetExpressionID(): UInt32 {
        return this.table.getUInt32Slot(EXPRESSIONID, 0)
    }
    func GetOperands() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(OPERANDS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetBlockGroups() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(BLOCKGROUPS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetParentBlock(): UInt32 {
        return this.table.getUInt32Slot(PARENTBLOCK, 0)
    }
    func GetResultLocalVar(): UInt32 {
        return this.table.getUInt32Slot(RESULTLOCALVAR, 0)
    }
    func GetResultTy(): UInt32 {
        return this.table.getUInt32Slot(RESULTTY, 0)
    }
    static func startExpression(builder: Builder): Unit { builder.startObject(8) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addKind(kind: PackageFormat_CHIRExprKind, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_CHIRExprKindValues(kind), 0)
    }
    static func addExpressionID(expressionID: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, expressionID, 0)
    }
    static func addOperandsVector(operands: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, operands, 0)
    }
    static func addBlockGroupsVector(blockGroups: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, blockGroups, 0)
    }
    static func addParentBlock(parentBlock: UInt32, builder: Builder) {
        builder.prependUInt32Slot(5, parentBlock, 0)
    }
    static func addResultLocalVar(resultLocalVar: UInt32, builder: Builder) {
        builder.prependUInt32Slot(6, resultLocalVar, 0)
    }
    static func addResultTy(resultTy: UInt32, builder: Builder) {
        builder.prependUInt32Slot(7, resultTy, 0)
    }
    static func endExpression(builder: Builder): UInt32 {return builder.endObject()}
    static func createExpression(
        builder: Builder,
        base: UInt32,
        kind: PackageFormat_CHIRExprKind,
        expressionID: UInt32,
        operands: UInt32,
        blockGroups: UInt32,
        parentBlock: UInt32,
        resultLocalVar: UInt32,
        resultTy: UInt32
    ): UInt32 {
        PackageFormat_Expression.startExpression(builder)
        PackageFormat_Expression.addResultTy(resultTy, builder)
        PackageFormat_Expression.addResultLocalVar(resultLocalVar, builder)
        PackageFormat_Expression.addParentBlock(parentBlock, builder)
        PackageFormat_Expression.addBlockGroupsVector(blockGroups, builder)
        PackageFormat_Expression.addOperandsVector(operands, builder)
        PackageFormat_Expression.addExpressionID(expressionID, builder)
        PackageFormat_Expression.addKind(kind, builder)
        PackageFormat_Expression.addBase(base, builder)
        return PackageFormat_Expression.endExpression(builder)
    }
}

public class PackageFormat_UnaryExpression <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let OVERFLOWSTRATEGY : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOverflowStrategy(): PackageFormat_OverflowStrategy {
        let o : UInt32 = UInt32(this.table.offset(OVERFLOWSTRATEGY))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_OverflowStrategy.OverflowStrategy_NA
        } else {
            EnumValuesPackageFormat_OverflowStrategy(this.table.getUInt8(off))
        }
    }
    static func startUnaryExpression(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOverflowStrategy(overflowStrategy: PackageFormat_OverflowStrategy, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_OverflowStrategyValues(overflowStrategy), 0)
    }
    static func endUnaryExpression(builder: Builder): UInt32 {return builder.endObject()}
    static func createUnaryExpression(
        builder: Builder,
        base: UInt32,
        overflowStrategy: PackageFormat_OverflowStrategy
    ): UInt32 {
        PackageFormat_UnaryExpression.startUnaryExpression(builder)
        PackageFormat_UnaryExpression.addOverflowStrategy(overflowStrategy, builder)
        PackageFormat_UnaryExpression.addBase(base, builder)
        return PackageFormat_UnaryExpression.endUnaryExpression(builder)
    }
}

public class PackageFormat_BinaryExpression <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let OVERFLOWSTRATEGY : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOverflowStrategy(): PackageFormat_OverflowStrategy {
        let o : UInt32 = UInt32(this.table.offset(OVERFLOWSTRATEGY))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_OverflowStrategy.OverflowStrategy_NA
        } else {
            EnumValuesPackageFormat_OverflowStrategy(this.table.getUInt8(off))
        }
    }
    static func startBinaryExpression(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOverflowStrategy(overflowStrategy: PackageFormat_OverflowStrategy, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_OverflowStrategyValues(overflowStrategy), 0)
    }
    static func endBinaryExpression(builder: Builder): UInt32 {return builder.endObject()}
    static func createBinaryExpression(
        builder: Builder,
        base: UInt32,
        overflowStrategy: PackageFormat_OverflowStrategy
    ): UInt32 {
        PackageFormat_BinaryExpression.startBinaryExpression(builder)
        PackageFormat_BinaryExpression.addOverflowStrategy(overflowStrategy, builder)
        PackageFormat_BinaryExpression.addBase(base, builder)
        return PackageFormat_BinaryExpression.endBinaryExpression(builder)
    }
}

public class PackageFormat_Constant <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startConstant(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endConstant(builder: Builder): UInt32 {return builder.endObject()}
    static func createConstant(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Constant.startConstant(builder)
        PackageFormat_Constant.addBase(base, builder)
        return PackageFormat_Constant.endConstant(builder)
    }
}

public class PackageFormat_Allocate <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let TARGETTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetTargetType(): UInt32 {
        return this.table.getUInt32Slot(TARGETTYPE, 0)
    }
    static func startAllocate(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addTargetType(targetType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, targetType, 0)
    }
    static func endAllocate(builder: Builder): UInt32 {return builder.endObject()}
    static func createAllocate(
        builder: Builder,
        base: UInt32,
        targetType: UInt32
    ): UInt32 {
        PackageFormat_Allocate.startAllocate(builder)
        PackageFormat_Allocate.addTargetType(targetType, builder)
        PackageFormat_Allocate.addBase(base, builder)
        return PackageFormat_Allocate.endAllocate(builder)
    }
}

public class PackageFormat_Load <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startLoad(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endLoad(builder: Builder): UInt32 {return builder.endObject()}
    static func createLoad(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Load.startLoad(builder)
        PackageFormat_Load.addBase(base, builder)
        return PackageFormat_Load.endLoad(builder)
    }
}

public class PackageFormat_Store <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startStore(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endStore(builder: Builder): UInt32 {return builder.endObject()}
    static func createStore(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Store.startStore(builder)
        PackageFormat_Store.addBase(base, builder)
        return PackageFormat_Store.endStore(builder)
    }
}

public class PackageFormat_GetElementRef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let PATH : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetPath() : Array<UInt64> {
        let o : UInt32 = UInt32(this.table.offset(PATH))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt64>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 8
            this.table.getUInt64(vecElement)
        }
    }
    static func startGetElementRef(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addPathVector(path: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, path, 0)
    }
    static func endGetElementRef(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetElementRef(
        builder: Builder,
        base: UInt32,
        path: UInt32
    ): UInt32 {
        PackageFormat_GetElementRef.startGetElementRef(builder)
        PackageFormat_GetElementRef.addPathVector(path, builder)
        PackageFormat_GetElementRef.addBase(base, builder)
        return PackageFormat_GetElementRef.endGetElementRef(builder)
    }
}

public class PackageFormat_GetElementByName <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let NAMES : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetNames() : Array<Option<String>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(NAMES)
        var arr: Array<Option<String>> = Array<Option<String>>(LENGTH, repeat: None<String>)
        let start: UInt32 = this.table.getVectorStartBySlot(NAMES)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<String>
            } else {
                Some<String>(this.table.getString(p))
            }
        }
        return arr
    }
    static func startGetElementByName(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addNamesVector(names: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, names, 0)
    }
    static func endGetElementByName(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetElementByName(
        builder: Builder,
        base: UInt32,
        names: UInt32
    ): UInt32 {
        PackageFormat_GetElementByName.startGetElementByName(builder)
        PackageFormat_GetElementByName.addNamesVector(names, builder)
        PackageFormat_GetElementByName.addBase(base, builder)
        return PackageFormat_GetElementByName.endGetElementByName(builder)
    }
}

public class PackageFormat_StoreElementRef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let PATH : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetPath() : Array<UInt64> {
        let o : UInt32 = UInt32(this.table.offset(PATH))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt64>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 8
            this.table.getUInt64(vecElement)
        }
    }
    static func startStoreElementRef(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addPathVector(path: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, path, 0)
    }
    static func endStoreElementRef(builder: Builder): UInt32 {return builder.endObject()}
    static func createStoreElementRef(
        builder: Builder,
        base: UInt32,
        path: UInt32
    ): UInt32 {
        PackageFormat_StoreElementRef.startStoreElementRef(builder)
        PackageFormat_StoreElementRef.addPathVector(path, builder)
        PackageFormat_StoreElementRef.addBase(base, builder)
        return PackageFormat_StoreElementRef.endStoreElementRef(builder)
    }
}

public class PackageFormat_StoreElementByName <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let NAMES : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetNames() : Array<Option<String>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(NAMES)
        var arr: Array<Option<String>> = Array<Option<String>>(LENGTH, repeat: None<String>)
        let start: UInt32 = this.table.getVectorStartBySlot(NAMES)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<String>
            } else {
                Some<String>(this.table.getString(p))
            }
        }
        return arr
    }
    static func startStoreElementByName(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addNamesVector(names: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, names, 0)
    }
    static func endStoreElementByName(builder: Builder): UInt32 {return builder.endObject()}
    static func createStoreElementByName(
        builder: Builder,
        base: UInt32,
        names: UInt32
    ): UInt32 {
        PackageFormat_StoreElementByName.startStoreElementByName(builder)
        PackageFormat_StoreElementByName.addNamesVector(names, builder)
        PackageFormat_StoreElementByName.addBase(base, builder)
        return PackageFormat_StoreElementByName.endStoreElementByName(builder)
    }
}

public class PackageFormat_VirMethodContext <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let SRCCODEIDENTIFIER : UInt16 = 4
    let ORIGINALFUNCTYPE : UInt16 = 6
    let GENERICTYPEPARAMS : UInt16 = 8

    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetOriginalFuncType(): UInt32 {
        return this.table.getUInt32Slot(ORIGINALFUNCTYPE, 0)
    }
    func GetGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(GENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startVirMethodContext(builder: Builder): Unit { builder.startObject(3) }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, srcCodeIdentifier, 0)
    }
    static func addOriginalFuncType(originalFuncType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, originalFuncType, 0)
    }
    static func addGenericTypeParamsVector(genericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, genericTypeParams, 0)
    }
    static func endVirMethodContext(builder: Builder): UInt32 {return builder.endObject()}
    static func createVirMethodContext(
        builder: Builder,
        srcCodeIdentifier: UInt32,
        originalFuncType: UInt32,
        genericTypeParams: UInt32
    ): UInt32 {
        PackageFormat_VirMethodContext.startVirMethodContext(builder)
        PackageFormat_VirMethodContext.addGenericTypeParamsVector(genericTypeParams, builder)
        PackageFormat_VirMethodContext.addOriginalFuncType(originalFuncType, builder)
        PackageFormat_VirMethodContext.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        return PackageFormat_VirMethodContext.endVirMethodContext(builder)
    }
}

public class PackageFormat_Apply <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ISSUPERCALL : UInt16 = 6
    let INSTANTIATEDTYPEARGS : UInt16 = 8
    let THISTYPE : UInt16 = 10

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIsSuperCall(): Bool {
        let o : UInt16 = this.table.offset(ISSUPERCALL)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    static func startApply(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIsSuperCall(isSuperCall: Bool, builder: Builder) {
        builder.prependBoolSlot(1, isSuperCall, false)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, instantiatedTypeArgs, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(3, thisType, 0)
    }
    static func endApply(builder: Builder): UInt32 {return builder.endObject()}
    static func createApply(
        builder: Builder,
        base: UInt32,
        isSuperCall: Bool,
        instantiatedTypeArgs: UInt32,
        thisType: UInt32
    ): UInt32 {
        PackageFormat_Apply.startApply(builder)
        PackageFormat_Apply.addThisType(thisType, builder)
        PackageFormat_Apply.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_Apply.addIsSuperCall(isSuperCall, builder)
        PackageFormat_Apply.addBase(base, builder)
        return PackageFormat_Apply.endApply(builder)
    }
}

public class PackageFormat_Invoke <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INSTANTIATEDTYPEARGS : UInt16 = 6
    let THISTYPE : UInt16 = 8
    let VIRMETHODCTX : UInt16 = 10

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    func GetVirMethodCtx(): Option<PackageFormat_VirMethodContext> {
        let o : UInt16 = this.table.offset(VIRMETHODCTX)
        return if (o == 0) {
            None<PackageFormat_VirMethodContext>
        } else {
            Some<PackageFormat_VirMethodContext>(PackageFormat_VirMethodContext(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startInvoke(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, instantiatedTypeArgs, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, thisType, 0)
    }
    static func addVirMethodCtx(virMethodCtx: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, virMethodCtx, 0)
    }
    static func endInvoke(builder: Builder): UInt32 {return builder.endObject()}
    static func createInvoke(
        builder: Builder,
        base: UInt32,
        instantiatedTypeArgs: UInt32,
        thisType: UInt32,
        virMethodCtx: UInt32
    ): UInt32 {
        PackageFormat_Invoke.startInvoke(builder)
        PackageFormat_Invoke.addVirMethodCtx(virMethodCtx, builder)
        PackageFormat_Invoke.addThisType(thisType, builder)
        PackageFormat_Invoke.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_Invoke.addBase(base, builder)
        return PackageFormat_Invoke.endInvoke(builder)
    }
}

public class PackageFormat_TypeCast <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let OVERFLOWSTRATEGY : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOverflowStrategy(): PackageFormat_OverflowStrategy {
        let o : UInt32 = UInt32(this.table.offset(OVERFLOWSTRATEGY))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_OverflowStrategy.OverflowStrategy_NA
        } else {
            EnumValuesPackageFormat_OverflowStrategy(this.table.getUInt8(off))
        }
    }
    static func startTypeCast(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOverflowStrategy(overflowStrategy: PackageFormat_OverflowStrategy, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_OverflowStrategyValues(overflowStrategy), 0)
    }
    static func endTypeCast(builder: Builder): UInt32 {return builder.endObject()}
    static func createTypeCast(
        builder: Builder,
        base: UInt32,
        overflowStrategy: PackageFormat_OverflowStrategy
    ): UInt32 {
        PackageFormat_TypeCast.startTypeCast(builder)
        PackageFormat_TypeCast.addOverflowStrategy(overflowStrategy, builder)
        PackageFormat_TypeCast.addBase(base, builder)
        return PackageFormat_TypeCast.endTypeCast(builder)
    }
}

public class PackageFormat_InstanceOf <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let TARGETTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetTargetType(): UInt32 {
        return this.table.getUInt32Slot(TARGETTYPE, 0)
    }
    static func startInstanceOf(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addTargetType(targetType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, targetType, 0)
    }
    static func endInstanceOf(builder: Builder): UInt32 {return builder.endObject()}
    static func createInstanceOf(
        builder: Builder,
        base: UInt32,
        targetType: UInt32
    ): UInt32 {
        PackageFormat_InstanceOf.startInstanceOf(builder)
        PackageFormat_InstanceOf.addTargetType(targetType, builder)
        PackageFormat_InstanceOf.addBase(base, builder)
        return PackageFormat_InstanceOf.endInstanceOf(builder)
    }
}

public class PackageFormat_Box <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startBox(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endBox(builder: Builder): UInt32 {return builder.endObject()}
    static func createBox(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Box.startBox(builder)
        PackageFormat_Box.addBase(base, builder)
        return PackageFormat_Box.endBox(builder)
    }
}

public class PackageFormat_UnBox <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startUnBox(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endUnBox(builder: Builder): UInt32 {return builder.endObject()}
    static func createUnBox(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_UnBox.startUnBox(builder)
        PackageFormat_UnBox.addBase(base, builder)
        return PackageFormat_UnBox.endUnBox(builder)
    }
}

public class PackageFormat_Terminator <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SUCCESSORS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSuccessors() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(SUCCESSORS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startTerminator(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSuccessorsVector(successors: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, successors, 0)
    }
    static func endTerminator(builder: Builder): UInt32 {return builder.endObject()}
    static func createTerminator(
        builder: Builder,
        base: UInt32,
        successors: UInt32
    ): UInt32 {
        PackageFormat_Terminator.startTerminator(builder)
        PackageFormat_Terminator.addSuccessorsVector(successors, builder)
        PackageFormat_Terminator.addBase(base, builder)
        return PackageFormat_Terminator.endTerminator(builder)
    }
}

public class PackageFormat_GoTo <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startGoTo(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endGoTo(builder: Builder): UInt32 {return builder.endObject()}
    static func createGoTo(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_GoTo.startGoTo(builder)
        PackageFormat_GoTo.addBase(base, builder)
        return PackageFormat_GoTo.endGoTo(builder)
    }
}

public class PackageFormat_Branch <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SOURCEEXPR : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSourceExpr(): PackageFormat_SourceExpr {
        let o : UInt32 = UInt32(this.table.offset(SOURCEEXPR))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_SourceExpr.SourceExpr_IF_EXPR
        } else {
            EnumValuesPackageFormat_SourceExpr(this.table.getUInt8(off))
        }
    }
    static func startBranch(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSourceExpr(sourceExpr: PackageFormat_SourceExpr, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_SourceExprValues(sourceExpr), 0)
    }
    static func endBranch(builder: Builder): UInt32 {return builder.endObject()}
    static func createBranch(
        builder: Builder,
        base: UInt32,
        sourceExpr: PackageFormat_SourceExpr
    ): UInt32 {
        PackageFormat_Branch.startBranch(builder)
        PackageFormat_Branch.addSourceExpr(sourceExpr, builder)
        PackageFormat_Branch.addBase(base, builder)
        return PackageFormat_Branch.endBranch(builder)
    }
}

public class PackageFormat_MultiBranch <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let CASEVALS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetCaseVals() : Array<UInt64> {
        let o : UInt32 = UInt32(this.table.offset(CASEVALS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt64>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 8
            this.table.getUInt64(vecElement)
        }
    }
    static func startMultiBranch(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addCaseValsVector(caseVals: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, caseVals, 0)
    }
    static func endMultiBranch(builder: Builder): UInt32 {return builder.endObject()}
    static func createMultiBranch(
        builder: Builder,
        base: UInt32,
        caseVals: UInt32
    ): UInt32 {
        PackageFormat_MultiBranch.startMultiBranch(builder)
        PackageFormat_MultiBranch.addCaseValsVector(caseVals, builder)
        PackageFormat_MultiBranch.addBase(base, builder)
        return PackageFormat_MultiBranch.endMultiBranch(builder)
    }
}

public class PackageFormat_Exit <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startExit(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endExit(builder: Builder): UInt32 {return builder.endObject()}
    static func createExit(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Exit.startExit(builder)
        PackageFormat_Exit.addBase(base, builder)
        return PackageFormat_Exit.endExit(builder)
    }
}

public class PackageFormat_RaiseException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startRaiseException(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endRaiseException(builder: Builder): UInt32 {return builder.endObject()}
    static func createRaiseException(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_RaiseException.startRaiseException(builder)
        PackageFormat_RaiseException.addBase(base, builder)
        return PackageFormat_RaiseException.endRaiseException(builder)
    }
}

public class PackageFormat_ApplyWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let THISTYPE : UInt16 = 6
    let INSTANTIATEDTYPEARGS : UInt16 = 8

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startApplyWithException(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, thisType, 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, instantiatedTypeArgs, 0)
    }
    static func endApplyWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createApplyWithException(
        builder: Builder,
        base: UInt32,
        thisType: UInt32,
        instantiatedTypeArgs: UInt32
    ): UInt32 {
        PackageFormat_ApplyWithException.startApplyWithException(builder)
        PackageFormat_ApplyWithException.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_ApplyWithException.addThisType(thisType, builder)
        PackageFormat_ApplyWithException.addBase(base, builder)
        return PackageFormat_ApplyWithException.endApplyWithException(builder)
    }
}

public class PackageFormat_InvokeWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INSTANTIATEDTYPEARGS : UInt16 = 6
    let THISTYPE : UInt16 = 8
    let VIRMETHODCTX : UInt16 = 10

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    func GetVirMethodCtx(): Option<PackageFormat_VirMethodContext> {
        let o : UInt16 = this.table.offset(VIRMETHODCTX)
        return if (o == 0) {
            None<PackageFormat_VirMethodContext>
        } else {
            Some<PackageFormat_VirMethodContext>(PackageFormat_VirMethodContext(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startInvokeWithException(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, instantiatedTypeArgs, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, thisType, 0)
    }
    static func addVirMethodCtx(virMethodCtx: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, virMethodCtx, 0)
    }
    static func endInvokeWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createInvokeWithException(
        builder: Builder,
        base: UInt32,
        instantiatedTypeArgs: UInt32,
        thisType: UInt32,
        virMethodCtx: UInt32
    ): UInt32 {
        PackageFormat_InvokeWithException.startInvokeWithException(builder)
        PackageFormat_InvokeWithException.addVirMethodCtx(virMethodCtx, builder)
        PackageFormat_InvokeWithException.addThisType(thisType, builder)
        PackageFormat_InvokeWithException.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_InvokeWithException.addBase(base, builder)
        return PackageFormat_InvokeWithException.endInvokeWithException(builder)
    }
}

public class PackageFormat_IntOpWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let OPKIND : UInt16 = 6
    let OVERFLOWSTRATEGY : UInt16 = 8

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetOpKind(): PackageFormat_CHIRExprKind {
        let o : UInt32 = UInt32(this.table.offset(OPKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_CHIRExprKind.CHIRExprKind_INVALID
        } else {
            EnumValuesPackageFormat_CHIRExprKind(this.table.getUInt8(off))
        }
    }
    func GetOverflowStrategy(): PackageFormat_OverflowStrategy {
        let o : UInt32 = UInt32(this.table.offset(OVERFLOWSTRATEGY))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_OverflowStrategy.OverflowStrategy_NA
        } else {
            EnumValuesPackageFormat_OverflowStrategy(this.table.getUInt8(off))
        }
    }
    static func startIntOpWithException(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addOpKind(opKind: PackageFormat_CHIRExprKind, builder: Builder) {
        builder.prependUInt8Slot(1, EnumPackageFormat_CHIRExprKindValues(opKind), 0)
    }
    static func addOverflowStrategy(overflowStrategy: PackageFormat_OverflowStrategy, builder: Builder) {
        builder.prependUInt8Slot(2, EnumPackageFormat_OverflowStrategyValues(overflowStrategy), 0)
    }
    static func endIntOpWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createIntOpWithException(
        builder: Builder,
        base: UInt32,
        opKind: PackageFormat_CHIRExprKind,
        overflowStrategy: PackageFormat_OverflowStrategy
    ): UInt32 {
        PackageFormat_IntOpWithException.startIntOpWithException(builder)
        PackageFormat_IntOpWithException.addOverflowStrategy(overflowStrategy, builder)
        PackageFormat_IntOpWithException.addOpKind(opKind, builder)
        PackageFormat_IntOpWithException.addBase(base, builder)
        return PackageFormat_IntOpWithException.endIntOpWithException(builder)
    }
}

public class PackageFormat_TypeCastWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startTypeCastWithException(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endTypeCastWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createTypeCastWithException(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_TypeCastWithException.startTypeCastWithException(builder)
        PackageFormat_TypeCastWithException.addBase(base, builder)
        return PackageFormat_TypeCastWithException.endTypeCastWithException(builder)
    }
}

public class PackageFormat_IntrinsicWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INTRINSICKIND : UInt16 = 6
    let INSTANTIATEDTYPEARGS : UInt16 = 8

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIntrinsicKind(): PackageFormat_IntrinsicKind {
        let o : UInt32 = UInt32(this.table.offset(INTRINSICKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_IntrinsicKind.IntrinsicKind_NOT_INTRINSIC
        } else {
            EnumValuesPackageFormat_IntrinsicKind(this.table.getUInt16(off))
        }
    }
    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startIntrinsicWithException(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIntrinsicKind(intrinsicKind: PackageFormat_IntrinsicKind, builder: Builder) {
        builder.prependUInt16Slot(1, EnumPackageFormat_IntrinsicKindValues(intrinsicKind), 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, instantiatedTypeArgs, 0)
    }
    static func endIntrinsicWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createIntrinsicWithException(
        builder: Builder,
        base: UInt32,
        intrinsicKind: PackageFormat_IntrinsicKind,
        instantiatedTypeArgs: UInt32
    ): UInt32 {
        PackageFormat_IntrinsicWithException.startIntrinsicWithException(builder)
        PackageFormat_IntrinsicWithException.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_IntrinsicWithException.addIntrinsicKind(intrinsicKind, builder)
        PackageFormat_IntrinsicWithException.addBase(base, builder)
        return PackageFormat_IntrinsicWithException.endIntrinsicWithException(builder)
    }
}

public class PackageFormat_AllocateWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let TARGETTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetTargetType(): UInt32 {
        return this.table.getUInt32Slot(TARGETTYPE, 0)
    }
    static func startAllocateWithException(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addTargetType(targetType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, targetType, 0)
    }
    static func endAllocateWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createAllocateWithException(
        builder: Builder,
        base: UInt32,
        targetType: UInt32
    ): UInt32 {
        PackageFormat_AllocateWithException.startAllocateWithException(builder)
        PackageFormat_AllocateWithException.addTargetType(targetType, builder)
        PackageFormat_AllocateWithException.addBase(base, builder)
        return PackageFormat_AllocateWithException.endAllocateWithException(builder)
    }
}

public class PackageFormat_RawArrayAllocateWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ELEMENTTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetElementType(): UInt32 {
        return this.table.getUInt32Slot(ELEMENTTYPE, 0)
    }
    static func startRawArrayAllocateWithException(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addElementType(elementType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, elementType, 0)
    }
    static func endRawArrayAllocateWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayAllocateWithException(
        builder: Builder,
        base: UInt32,
        elementType: UInt32
    ): UInt32 {
        PackageFormat_RawArrayAllocateWithException.startRawArrayAllocateWithException(builder)
        PackageFormat_RawArrayAllocateWithException.addElementType(elementType, builder)
        PackageFormat_RawArrayAllocateWithException.addBase(base, builder)
        return PackageFormat_RawArrayAllocateWithException.endRawArrayAllocateWithException(builder)
    }
}

public class PackageFormat_RawArrayLiteralAllocateWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ELEMENTTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetElementType(): UInt32 {
        return this.table.getUInt32Slot(ELEMENTTYPE, 0)
    }
    static func startRawArrayLiteralAllocateWithException(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addElementType(elementType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, elementType, 0)
    }
    static func endRawArrayLiteralAllocateWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayLiteralAllocateWithException(
        builder: Builder,
        base: UInt32,
        elementType: UInt32
    ): UInt32 {
        PackageFormat_RawArrayLiteralAllocateWithException.startRawArrayLiteralAllocateWithException(builder)
        PackageFormat_RawArrayLiteralAllocateWithException.addElementType(elementType, builder)
        PackageFormat_RawArrayLiteralAllocateWithException.addBase(base, builder)
        return PackageFormat_RawArrayLiteralAllocateWithException.endRawArrayLiteralAllocateWithException(builder)
    }
}

public class PackageFormat_SpawnWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXECUTECLOSURE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExecuteClosure(): UInt32 {
        return this.table.getUInt32Slot(EXECUTECLOSURE, 0)
    }
    static func startSpawnWithException(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExecuteClosure(executeClosure: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, executeClosure, 0)
    }
    static func endSpawnWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createSpawnWithException(
        builder: Builder,
        base: UInt32,
        executeClosure: UInt32
    ): UInt32 {
        PackageFormat_SpawnWithException.startSpawnWithException(builder)
        PackageFormat_SpawnWithException.addExecuteClosure(executeClosure, builder)
        PackageFormat_SpawnWithException.addBase(base, builder)
        return PackageFormat_SpawnWithException.endSpawnWithException(builder)
    }
}

public class PackageFormat_Tuple <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startTuple(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endTuple(builder: Builder): UInt32 {return builder.endObject()}
    static func createTuple(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Tuple.startTuple(builder)
        PackageFormat_Tuple.addBase(base, builder)
        return PackageFormat_Tuple.endTuple(builder)
    }
}

public class PackageFormat_Field <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let PATH : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetPath() : Array<UInt64> {
        let o : UInt32 = UInt32(this.table.offset(PATH))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt64>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 8
            this.table.getUInt64(vecElement)
        }
    }
    static func startField(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addPathVector(path: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, path, 0)
    }
    static func endField(builder: Builder): UInt32 {return builder.endObject()}
    static func createField(
        builder: Builder,
        base: UInt32,
        path: UInt32
    ): UInt32 {
        PackageFormat_Field.startField(builder)
        PackageFormat_Field.addPathVector(path, builder)
        PackageFormat_Field.addBase(base, builder)
        return PackageFormat_Field.endField(builder)
    }
}

public class PackageFormat_FieldByName <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let NAMES : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetNames() : Array<Option<String>> {
        let ELEMENT_STRIDE: UInt32 = 4
        let LENGTH: Int64 = this.table.getVectorLenBySlot(NAMES)
        var arr: Array<Option<String>> = Array<Option<String>>(LENGTH, repeat: None<String>)
        let start: UInt32 = this.table.getVectorStartBySlot(NAMES)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                None<String>
            } else {
                Some<String>(this.table.getString(p))
            }
        }
        return arr
    }
    static func startFieldByName(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addNamesVector(names: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, names, 0)
    }
    static func endFieldByName(builder: Builder): UInt32 {return builder.endObject()}
    static func createFieldByName(
        builder: Builder,
        base: UInt32,
        names: UInt32
    ): UInt32 {
        PackageFormat_FieldByName.startFieldByName(builder)
        PackageFormat_FieldByName.addNamesVector(names, builder)
        PackageFormat_FieldByName.addBase(base, builder)
        return PackageFormat_FieldByName.endFieldByName(builder)
    }
}

public class PackageFormat_RawArrayAllocate <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ELEMENTTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetElementType(): UInt32 {
        return this.table.getUInt32Slot(ELEMENTTYPE, 0)
    }
    static func startRawArrayAllocate(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addElementType(elementType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, elementType, 0)
    }
    static func endRawArrayAllocate(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayAllocate(
        builder: Builder,
        base: UInt32,
        elementType: UInt32
    ): UInt32 {
        PackageFormat_RawArrayAllocate.startRawArrayAllocate(builder)
        PackageFormat_RawArrayAllocate.addElementType(elementType, builder)
        PackageFormat_RawArrayAllocate.addBase(base, builder)
        return PackageFormat_RawArrayAllocate.endRawArrayAllocate(builder)
    }
}

public class PackageFormat_RawArrayLiteralAllocate <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let ELEMENTTYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetElementType(): UInt32 {
        return this.table.getUInt32Slot(ELEMENTTYPE, 0)
    }
    static func startRawArrayLiteralAllocate(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addElementType(elementType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, elementType, 0)
    }
    static func endRawArrayLiteralAllocate(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayLiteralAllocate(
        builder: Builder,
        base: UInt32,
        elementType: UInt32
    ): UInt32 {
        PackageFormat_RawArrayLiteralAllocate.startRawArrayLiteralAllocate(builder)
        PackageFormat_RawArrayLiteralAllocate.addElementType(elementType, builder)
        PackageFormat_RawArrayLiteralAllocate.addBase(base, builder)
        return PackageFormat_RawArrayLiteralAllocate.endRawArrayLiteralAllocate(builder)
    }
}

public class PackageFormat_RawArrayLiteralInit <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startRawArrayLiteralInit(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endRawArrayLiteralInit(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayLiteralInit(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_RawArrayLiteralInit.startRawArrayLiteralInit(builder)
        PackageFormat_RawArrayLiteralInit.addBase(base, builder)
        return PackageFormat_RawArrayLiteralInit.endRawArrayLiteralInit(builder)
    }
}

public class PackageFormat_RawArrayInitByValue <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startRawArrayInitByValue(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endRawArrayInitByValue(builder: Builder): UInt32 {return builder.endObject()}
    static func createRawArrayInitByValue(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_RawArrayInitByValue.startRawArrayInitByValue(builder)
        PackageFormat_RawArrayInitByValue.addBase(base, builder)
        return PackageFormat_RawArrayInitByValue.endRawArrayInitByValue(builder)
    }
}

public class PackageFormat_VArray <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startVArray_(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endVArray_(builder: Builder): UInt32 {return builder.endObject()}
    static func createVArray_(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_VArray.startVArray_(builder)
        PackageFormat_VArray.addBase(base, builder)
        return PackageFormat_VArray.endVArray_(builder)
    }
}

public class PackageFormat_VArrayBd <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startVArrayBd(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endVArrayBd(builder: Builder): UInt32 {return builder.endObject()}
    static func createVArrayBd(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_VArrayBd.startVArrayBd(builder)
        PackageFormat_VArrayBd.addBase(base, builder)
        return PackageFormat_VArrayBd.endVArrayBd(builder)
    }
}

public class PackageFormat_GetException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startGetException(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endGetException(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetException(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_GetException.startGetException(builder)
        PackageFormat_GetException.addBase(base, builder)
        return PackageFormat_GetException.endGetException(builder)
    }
}

public class PackageFormat_Intrinsic <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INTRINSICKIND : UInt16 = 6
    let INSTANTIATEDTYPEARGS : UInt16 = 8

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetIntrinsicKind(): PackageFormat_IntrinsicKind {
        let o : UInt32 = UInt32(this.table.offset(INTRINSICKIND))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_IntrinsicKind.IntrinsicKind_NOT_INTRINSIC
        } else {
            EnumValuesPackageFormat_IntrinsicKind(this.table.getUInt16(off))
        }
    }
    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startIntrinsic(builder: Builder): Unit { builder.startObject(3) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addIntrinsicKind(intrinsicKind: PackageFormat_IntrinsicKind, builder: Builder) {
        builder.prependUInt16Slot(1, EnumPackageFormat_IntrinsicKindValues(intrinsicKind), 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(2, instantiatedTypeArgs, 0)
    }
    static func endIntrinsic(builder: Builder): UInt32 {return builder.endObject()}
    static func createIntrinsic(
        builder: Builder,
        base: UInt32,
        intrinsicKind: PackageFormat_IntrinsicKind,
        instantiatedTypeArgs: UInt32
    ): UInt32 {
        PackageFormat_Intrinsic.startIntrinsic(builder)
        PackageFormat_Intrinsic.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_Intrinsic.addIntrinsicKind(intrinsicKind, builder)
        PackageFormat_Intrinsic.addBase(base, builder)
        return PackageFormat_Intrinsic.endIntrinsic(builder)
    }
}

public class PackageFormat_If <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startIf(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endIf(builder: Builder): UInt32 {return builder.endObject()}
    static func createIf(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_If.startIf(builder)
        PackageFormat_If.addBase(base, builder)
        return PackageFormat_If.endIf(builder)
    }
}

public class PackageFormat_Loop <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startLoop(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endLoop(builder: Builder): UInt32 {return builder.endObject()}
    static func createLoop(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_Loop.startLoop(builder)
        PackageFormat_Loop.addBase(base, builder)
        return PackageFormat_Loop.endLoop(builder)
    }
}

public class PackageFormat_ForInRange <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startForInRange(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endForInRange(builder: Builder): UInt32 {return builder.endObject()}
    static func createForInRange(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_ForInRange.startForInRange(builder)
        PackageFormat_ForInRange.addBase(base, builder)
        return PackageFormat_ForInRange.endForInRange(builder)
    }
}

public class PackageFormat_ForInIter <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startForInIter(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endForInIter(builder: Builder): UInt32 {return builder.endObject()}
    static func createForInIter(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_ForInIter.startForInIter(builder)
        PackageFormat_ForInIter.addBase(base, builder)
        return PackageFormat_ForInIter.endForInIter(builder)
    }
}

public class PackageFormat_ForInClosedRange <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startForInClosedRange(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endForInClosedRange(builder: Builder): UInt32 {return builder.endObject()}
    static func createForInClosedRange(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_ForInClosedRange.startForInClosedRange(builder)
        PackageFormat_ForInClosedRange.addBase(base, builder)
        return PackageFormat_ForInClosedRange.endForInClosedRange(builder)
    }
}

public class PackageFormat_Debug <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let SRCCODEIDENTIFIER : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    static func startDebug(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, srcCodeIdentifier, 0)
    }
    static func endDebug(builder: Builder): UInt32 {return builder.endObject()}
    static func createDebug(
        builder: Builder,
        base: UInt32,
        srcCodeIdentifier: UInt32
    ): UInt32 {
        PackageFormat_Debug.startDebug(builder)
        PackageFormat_Debug.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_Debug.addBase(base, builder)
        return PackageFormat_Debug.endDebug(builder)
    }
}

public class PackageFormat_Spawn <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let EXECUTECLOSURE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetExecuteClosure(): UInt32 {
        return this.table.getUInt32Slot(EXECUTECLOSURE, 0)
    }
    static func startSpawn(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addExecuteClosure(executeClosure: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, executeClosure, 0)
    }
    static func endSpawn(builder: Builder): UInt32 {return builder.endObject()}
    static func createSpawn(
        builder: Builder,
        base: UInt32,
        executeClosure: UInt32
    ): UInt32 {
        PackageFormat_Spawn.startSpawn(builder)
        PackageFormat_Spawn.addExecuteClosure(executeClosure, builder)
        PackageFormat_Spawn.addBase(base, builder)
        return PackageFormat_Spawn.endSpawn(builder)
    }
}

public class PackageFormat_Lambda <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let FUNCTY : UInt16 = 6
    let ISLOCALFUNC : UInt16 = 8
    let IDENTIFIER : UInt16 = 10
    let SRCCODEIDENTIFIER : UInt16 = 12
    let PARAMS : UInt16 = 14
    let GENERICTYPEPARAMS : UInt16 = 16
    let BODY : UInt16 = 18
    let RETVAL : UInt16 = 20
    let ISCOMPILETIMEVALUE : UInt16 = 22

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetFuncTy(): UInt32 {
        return this.table.getUInt32Slot(FUNCTY, 0)
    }
    func GetIsLocalFunc(): Bool {
        let o : UInt16 = this.table.offset(ISLOCALFUNC)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    func GetIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(IDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetSrcCodeIdentifier(): String {
        let o : UInt32 = UInt32(this.table.offset(SRCCODEIDENTIFIER)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(PARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetGenericTypeParams() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(GENERICTYPEPARAMS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetBody(): UInt32 {
        return this.table.getUInt32Slot(BODY, 0)
    }
    func GetRetVal(): UInt32 {
        return this.table.getUInt32Slot(RETVAL, 0)
    }
    func GetIsCompileTimeValue(): Bool {
        let o : UInt16 = this.table.offset(ISCOMPILETIMEVALUE)
        return if (o == 0) {
            false
        } else {
            this.table.getBool(UInt32(o) + this.table.pos)
        }
    }
    static func startLambda(builder: Builder): Unit { builder.startObject(10) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addFuncTy(funcTy: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, funcTy, 0)
    }
    static func addIsLocalFunc(isLocalFunc: Bool, builder: Builder) {
        builder.prependBoolSlot(2, isLocalFunc, false)
    }
    static func addIdentifier(identifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, identifier, 0)
    }
    static func addSrcCodeIdentifier(srcCodeIdentifier: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, srcCodeIdentifier, 0)
    }
    static func addParamsVector(params: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, params, 0)
    }
    static func addGenericTypeParamsVector(genericTypeParams: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(6, genericTypeParams, 0)
    }
    static func addBody(body: UInt32, builder: Builder) {
        builder.prependUInt32Slot(7, body, 0)
    }
    static func addRetVal(retVal: UInt32, builder: Builder) {
        builder.prependUInt32Slot(8, retVal, 0)
    }
    static func addIsCompileTimeValue(isCompileTimeValue: Bool, builder: Builder) {
        builder.prependBoolSlot(9, isCompileTimeValue, false)
    }
    static func endLambda(builder: Builder): UInt32 {return builder.endObject()}
    static func createLambda(
        builder: Builder,
        base: UInt32,
        funcTy: UInt32,
        isLocalFunc: Bool,
        identifier: UInt32,
        srcCodeIdentifier: UInt32,
        params: UInt32,
        genericTypeParams: UInt32,
        body: UInt32,
        retVal: UInt32,
        isCompileTimeValue: Bool
    ): UInt32 {
        PackageFormat_Lambda.startLambda(builder)
        PackageFormat_Lambda.addIsCompileTimeValue(isCompileTimeValue, builder)
        PackageFormat_Lambda.addRetVal(retVal, builder)
        PackageFormat_Lambda.addBody(body, builder)
        PackageFormat_Lambda.addGenericTypeParamsVector(genericTypeParams, builder)
        PackageFormat_Lambda.addParamsVector(params, builder)
        PackageFormat_Lambda.addSrcCodeIdentifier(srcCodeIdentifier, builder)
        PackageFormat_Lambda.addIdentifier(identifier, builder)
        PackageFormat_Lambda.addIsLocalFunc(isLocalFunc, builder)
        PackageFormat_Lambda.addFuncTy(funcTy, builder)
        PackageFormat_Lambda.addBase(base, builder)
        return PackageFormat_Lambda.endLambda(builder)
    }
}

public class PackageFormat_InvokeStatic <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INSTANTIATEDTYPEARGS : UInt16 = 6
    let THISTYPE : UInt16 = 8
    let VIRMETHODCTX : UInt16 = 10

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    func GetVirMethodCtx(): Option<PackageFormat_VirMethodContext> {
        let o : UInt16 = this.table.offset(VIRMETHODCTX)
        return if (o == 0) {
            None<PackageFormat_VirMethodContext>
        } else {
            Some<PackageFormat_VirMethodContext>(PackageFormat_VirMethodContext(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startInvokeStatic(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, instantiatedTypeArgs, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, thisType, 0)
    }
    static func addVirMethodCtx(virMethodCtx: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, virMethodCtx, 0)
    }
    static func endInvokeStatic(builder: Builder): UInt32 {return builder.endObject()}
    static func createInvokeStatic(
        builder: Builder,
        base: UInt32,
        instantiatedTypeArgs: UInt32,
        thisType: UInt32,
        virMethodCtx: UInt32
    ): UInt32 {
        PackageFormat_InvokeStatic.startInvokeStatic(builder)
        PackageFormat_InvokeStatic.addVirMethodCtx(virMethodCtx, builder)
        PackageFormat_InvokeStatic.addThisType(thisType, builder)
        PackageFormat_InvokeStatic.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_InvokeStatic.addBase(base, builder)
        return PackageFormat_InvokeStatic.endInvokeStatic(builder)
    }
}

public class PackageFormat_GetInstantiateValue <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INSTANTIATETYS : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInstantiateTys() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATETYS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    static func startGetInstantiateValue(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addInstantiateTysVector(instantiateTys: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, instantiateTys, 0)
    }
    static func endGetInstantiateValue(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetInstantiateValue(
        builder: Builder,
        base: UInt32,
        instantiateTys: UInt32
    ): UInt32 {
        PackageFormat_GetInstantiateValue.startGetInstantiateValue(builder)
        PackageFormat_GetInstantiateValue.addInstantiateTysVector(instantiateTys, builder)
        PackageFormat_GetInstantiateValue.addBase(base, builder)
        return PackageFormat_GetInstantiateValue.endGetInstantiateValue(builder)
    }
}

public class PackageFormat_InvokeStaticWithException <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let INSTANTIATEDTYPEARGS : UInt16 = 6
    let THISTYPE : UInt16 = 8
    let VIRMETHODCTX : UInt16 = 10

    func GetBase(): Option<PackageFormat_Terminator> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Terminator>
        } else {
            Some<PackageFormat_Terminator>(PackageFormat_Terminator(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetInstantiatedTypeArgs() : Array<UInt32> {
        let o : UInt32 = UInt32(this.table.offset(INSTANTIATEDTYPEARGS))
        let vectorLoc: UInt32 = this.table.getIndirect(o + this.table.pos)
        let vectorLength: UInt32 = this.table.getUInt32(vectorLoc)
        let vectorStart = vectorLoc + 4
        return Array<UInt32>(Int64(vectorLength)) { i =>
            let vecElement = vectorStart + UInt32(i) * 4
            this.table.getUInt32(vecElement)
        }
    }
    func GetThisType(): UInt32 {
        return this.table.getUInt32Slot(THISTYPE, 0)
    }
    func GetVirMethodCtx(): Option<PackageFormat_VirMethodContext> {
        let o : UInt16 = this.table.offset(VIRMETHODCTX)
        return if (o == 0) {
            None<PackageFormat_VirMethodContext>
        } else {
            Some<PackageFormat_VirMethodContext>(PackageFormat_VirMethodContext(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startInvokeStaticWithException(builder: Builder): Unit { builder.startObject(4) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addInstantiatedTypeArgsVector(instantiatedTypeArgs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, instantiatedTypeArgs, 0)
    }
    static func addThisType(thisType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(2, thisType, 0)
    }
    static func addVirMethodCtx(virMethodCtx: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, virMethodCtx, 0)
    }
    static func endInvokeStaticWithException(builder: Builder): UInt32 {return builder.endObject()}
    static func createInvokeStaticWithException(
        builder: Builder,
        base: UInt32,
        instantiatedTypeArgs: UInt32,
        thisType: UInt32,
        virMethodCtx: UInt32
    ): UInt32 {
        PackageFormat_InvokeStaticWithException.startInvokeStaticWithException(builder)
        PackageFormat_InvokeStaticWithException.addVirMethodCtx(virMethodCtx, builder)
        PackageFormat_InvokeStaticWithException.addThisType(thisType, builder)
        PackageFormat_InvokeStaticWithException.addInstantiatedTypeArgsVector(instantiatedTypeArgs, builder)
        PackageFormat_InvokeStaticWithException.addBase(base, builder)
        return PackageFormat_InvokeStaticWithException.endInvokeStaticWithException(builder)
    }
}

public class PackageFormat_TransformToGeneric <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startTransformToGeneric(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endTransformToGeneric(builder: Builder): UInt32 {return builder.endObject()}
    static func createTransformToGeneric(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_TransformToGeneric.startTransformToGeneric(builder)
        PackageFormat_TransformToGeneric.addBase(base, builder)
        return PackageFormat_TransformToGeneric.endTransformToGeneric(builder)
    }
}

public class PackageFormat_TransformToConcrete <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startTransformToConcrete(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endTransformToConcrete(builder: Builder): UInt32 {return builder.endObject()}
    static func createTransformToConcrete(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_TransformToConcrete.startTransformToConcrete(builder)
        PackageFormat_TransformToConcrete.addBase(base, builder)
        return PackageFormat_TransformToConcrete.endTransformToConcrete(builder)
    }
}

public class PackageFormat_UnBoxToRef <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startUnBoxToRef(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endUnBoxToRef(builder: Builder): UInt32 {return builder.endObject()}
    static func createUnBoxToRef(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_UnBoxToRef.startUnBoxToRef(builder)
        PackageFormat_UnBoxToRef.addBase(base, builder)
        return PackageFormat_UnBoxToRef.endUnBoxToRef(builder)
    }
}

public class PackageFormat_GetRTTI <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    static func startGetRTTI(builder: Builder): Unit { builder.startObject(1) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func endGetRTTI(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetRTTI(
        builder: Builder,
        base: UInt32
    ): UInt32 {
        PackageFormat_GetRTTI.startGetRTTI(builder)
        PackageFormat_GetRTTI.addBase(base, builder)
        return PackageFormat_GetRTTI.endGetRTTI(builder)
    }
}

public class PackageFormat_GetRTTIStatic <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let BASE : UInt16 = 4
    let RTTITYPE : UInt16 = 6

    func GetBase(): Option<PackageFormat_Expression> {
        let o : UInt16 = this.table.offset(BASE)
        return if (o == 0) {
            None<PackageFormat_Expression>
        } else {
            Some<PackageFormat_Expression>(PackageFormat_Expression(this.table.bytes, UInt32(o) + this.table.pos))
        }
    }

    func GetRttiType(): UInt32 {
        return this.table.getUInt32Slot(RTTITYPE, 0)
    }
    static func startGetRTTIStatic(builder: Builder): Unit { builder.startObject(2) }
    static func addBase(base: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, base, 0)
    }
    static func addRttiType(rttiType: UInt32, builder: Builder) {
        builder.prependUInt32Slot(1, rttiType, 0)
    }
    static func endGetRTTIStatic(builder: Builder): UInt32 {return builder.endObject()}
    static func createGetRTTIStatic(
        builder: Builder,
        base: UInt32,
        rttiType: UInt32
    ): UInt32 {
        PackageFormat_GetRTTIStatic.startGetRTTIStatic(builder)
        PackageFormat_GetRTTIStatic.addRttiType(rttiType, builder)
        PackageFormat_GetRTTIStatic.addBase(base, builder)
        return PackageFormat_GetRTTIStatic.endGetRTTIStatic(builder)
    }
}

public class PackageFormat_CHIRPackage <: FlatBufferObject {
    init(buf: Array<UInt8>, offset: UInt32) {
        super(buf, offset)
    }

    let NAME : UInt16 = 4
    let PATH : UInt16 = 6
    let PKGACCESSLEVEL : UInt16 = 8
    let TYPES_TYPE : UInt16 = 10
    let TYPES : UInt16 = 12
    let VALUES_TYPE : UInt16 = 14
    let VALUES : UInt16 = 16
    let EXPRS_TYPE : UInt16 = 18
    let EXPRS : UInt16 = 20
    let DEFS_TYPE : UInt16 = 22
    let DEFS : UInt16 = 24
    let PACKAGEINITFUNC : UInt16 = 26
    let PHASE : UInt16 = 28
    let PACKAGELITERALINITFUNC : UInt16 = 30
    let MAXIMPORTEDVALUEID : UInt16 = 32
    let MAXIMPORTEDSTRUCTID : UInt16 = 34
    let MAXIMPORTEDCLASSID : UInt16 = 36
    let MAXIMPORTEDENUMID : UInt16 = 38
    let MAXIMPORTEDEXTENDID : UInt16 = 40

    func GetName(): String {
        let o : UInt32 = UInt32(this.table.offset(NAME)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPath(): String {
        let o : UInt32 = UInt32(this.table.offset(PATH)) + this.table.pos
        return if (o == 0) {
            ""
        } else {
            this.table.getString(o)
        }
    }
    func GetPkgAccessLevel(): PackageFormat_PackageAccessLevel {
        let o : UInt32 = UInt32(this.table.offset(PKGACCESSLEVEL))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_PackageAccessLevel.PackageAccessLevel_INVALID
        } else {
            EnumValuesPackageFormat_PackageAccessLevel(this.table.getUInt8(off))
        }
    }
    func GetTypesType() : Array<Option<PackageFormat_TypeElem>> {
        let ELEMENT_STRIDE: UInt32 = 1
        let LENGTH: Int64 = this.table.getVectorLenBySlot(TYPES_TYPE)
        var arr = Array<?PackageFormat_TypeElem>(LENGTH, repeat: None<PackageFormat_TypeElem>)
        let start: UInt32 = this.table.getVectorStartBySlot(TYPES_TYPE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                EnumValuesPackageFormat_TypeElem(0)
            } else {
                EnumValuesPackageFormat_TypeElem(this.table.getUInt8(p))
            }
        }
        return arr
    }
    func GetTypes(index: Int32) : FlatBufferObject {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorLoc: UInt32 = this.table.getIndirect(UInt32(o) + this.table.pos)
        let vectorStart = vectorLoc + 4
        if (o == 0) {
            FlatBufferObject(Array<UInt8>(), 0)
        } else {
            table.getUnion(vectorStart + UInt32(index) * 4)
        }
    }
    func GetTypesSize(): Int64 {
        table.getVectorLenBySlot(TYPES_TYPE)
    }
    func GetTypesType(index: UInt32): PackageFormat_TypeElem {
        let start = this.table.getVectorStartBySlot(TYPES_TYPE)
        EnumValuesPackageFormat_TypeElem(this.table.getUInt8(start + index))
    }

    func GetTypesAsRuneType(index: UInt32) : ?PackageFormat_RuneType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_RUNETYPE => Some(PackageFormat_RuneType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RuneType>
        }
    }

    func GetTypesAsBooleanType(index: UInt32) : ?PackageFormat_BooleanType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_BOOLEANTYPE => Some(PackageFormat_BooleanType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_BooleanType>
        }
    }

    func GetTypesAsUnitType(index: UInt32) : ?PackageFormat_UnitType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_UNITTYPE => Some(PackageFormat_UnitType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_UnitType>
        }
    }

    func GetTypesAsNothingType(index: UInt32) : ?PackageFormat_NothingType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_NOTHINGTYPE => Some(PackageFormat_NothingType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_NothingType>
        }
    }

    func GetTypesAsIntType(index: UInt32) : ?PackageFormat_IntType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_INTTYPE => Some(PackageFormat_IntType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IntType>
        }
    }

    func GetTypesAsFloatType(index: UInt32) : ?PackageFormat_FloatType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_FLOATTYPE => Some(PackageFormat_FloatType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_FloatType>
        }
    }

    func GetTypesAsTupleType(index: UInt32) : ?PackageFormat_TupleType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_TUPLETYPE => Some(PackageFormat_TupleType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_TupleType>
        }
    }

    func GetTypesAsRawArrayType(index: UInt32) : ?PackageFormat_RawArrayType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_RAWARRAYTYPE => Some(PackageFormat_RawArrayType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RawArrayType>
        }
    }

    func GetTypesAsVArrayType(index: UInt32) : ?PackageFormat_VArrayType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_VARRAYTYPE => Some(PackageFormat_VArrayType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VArrayType>
        }
    }

    func GetTypesAsFuncType(index: UInt32) : ?PackageFormat_FuncType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_FUNCTYPE => Some(PackageFormat_FuncType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_FuncType>
        }
    }

    func GetTypesAsCustomType(index: UInt32) : ?PackageFormat_CustomType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_CUSTOMTYPE => Some(PackageFormat_CustomType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_CustomType>
        }
    }

    func GetTypesAsEnumType(index: UInt32) : ?PackageFormat_EnumType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_ENUMTYPE => Some(PackageFormat_EnumType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_EnumType>
        }
    }

    func GetTypesAsStructType(index: UInt32) : ?PackageFormat_StructType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_STRUCTTYPE => Some(PackageFormat_StructType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_StructType>
        }
    }

    func GetTypesAsClassType(index: UInt32) : ?PackageFormat_ClassType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_CLASSTYPE => Some(PackageFormat_ClassType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ClassType>
        }
    }

    func GetTypesAsCStringType(index: UInt32) : ?PackageFormat_CStringType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_CSTRINGTYPE => Some(PackageFormat_CStringType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_CStringType>
        }
    }

    func GetTypesAsCPointerType(index: UInt32) : ?PackageFormat_CPointerType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_CPOINTERTYPE => Some(PackageFormat_CPointerType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_CPointerType>
        }
    }

    func GetTypesAsGenericType(index: UInt32) : ?PackageFormat_GenericType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_GENERICTYPE => Some(PackageFormat_GenericType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GenericType>
        }
    }

    func GetTypesAsRefType(index: UInt32) : ?PackageFormat_RefType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_REFTYPE => Some(PackageFormat_RefType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RefType>
        }
    }

    func GetTypesAsBoxType(index: UInt32) : ?PackageFormat_BoxType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_BOXTYPE => Some(PackageFormat_BoxType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_BoxType>
        }
    }

    func GetTypesAsVoidType(index: UInt32) : ?PackageFormat_VoidType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_VOIDTYPE => Some(PackageFormat_VoidType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VoidType>
        }
    }

    func GetTypesAsThisType(index: UInt32) : ?PackageFormat_ThisType {
        let o : UInt16 = this.table.offset(TYPES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetTypesType(index)) {
            case PackageFormat_TypeElem.TypeElem_THISTYPE => Some(PackageFormat_ThisType(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ThisType>
        }
    }

    func GetValuesType() : Array<Option<PackageFormat_ValueElem>> {
        let ELEMENT_STRIDE: UInt32 = 1
        let LENGTH: Int64 = this.table.getVectorLenBySlot(VALUES_TYPE)
        var arr = Array<?PackageFormat_ValueElem>(LENGTH, repeat: None<PackageFormat_ValueElem>)
        let start: UInt32 = this.table.getVectorStartBySlot(VALUES_TYPE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                EnumValuesPackageFormat_ValueElem(0)
            } else {
                EnumValuesPackageFormat_ValueElem(this.table.getUInt8(p))
            }
        }
        return arr
    }
    func GetValues(index: Int32) : FlatBufferObject {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorLoc: UInt32 = this.table.getIndirect(UInt32(o) + this.table.pos)
        let vectorStart = vectorLoc + 4
        if (o == 0) {
            FlatBufferObject(Array<UInt8>(), 0)
        } else {
            table.getUnion(vectorStart + UInt32(index) * 4)
        }
    }
    func GetValuesSize(): Int64 {
        table.getVectorLenBySlot(VALUES_TYPE)
    }
    func GetValuesType(index: UInt32): PackageFormat_ValueElem {
        let start = this.table.getVectorStartBySlot(VALUES_TYPE)
        EnumValuesPackageFormat_ValueElem(this.table.getUInt8(start + index))
    }

    func GetValuesAsBoolLiteral(index: UInt32) : ?PackageFormat_BoolLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_BOOLLITERAL => Some(PackageFormat_BoolLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_BoolLiteral>
        }
    }

    func GetValuesAsRuneLiteral(index: UInt32) : ?PackageFormat_RuneLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_RUNELITERAL => Some(PackageFormat_RuneLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RuneLiteral>
        }
    }

    func GetValuesAsStringLiteral(index: UInt32) : ?PackageFormat_StringLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_STRINGLITERAL => Some(PackageFormat_StringLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_StringLiteral>
        }
    }

    func GetValuesAsIntLiteral(index: UInt32) : ?PackageFormat_IntLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_INTLITERAL => Some(PackageFormat_IntLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IntLiteral>
        }
    }

    func GetValuesAsFloatLiteral(index: UInt32) : ?PackageFormat_FloatLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_FLOATLITERAL => Some(PackageFormat_FloatLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_FloatLiteral>
        }
    }

    func GetValuesAsUnitLiteral(index: UInt32) : ?PackageFormat_UnitLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_UNITLITERAL => Some(PackageFormat_UnitLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_UnitLiteral>
        }
    }

    func GetValuesAsNullLiteral(index: UInt32) : ?PackageFormat_NullLiteral {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_NULLLITERAL => Some(PackageFormat_NullLiteral(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_NullLiteral>
        }
    }

    func GetValuesAsParameter(index: UInt32) : ?PackageFormat_Parameter {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_PARAMETER => Some(PackageFormat_Parameter(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Parameter>
        }
    }

    func GetValuesAsLocalVar(index: UInt32) : ?PackageFormat_LocalVar {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_LOCALVAR => Some(PackageFormat_LocalVar(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_LocalVar>
        }
    }

    func GetValuesAsGlobalVar(index: UInt32) : ?PackageFormat_GlobalVar {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_GLOBALVAR => Some(PackageFormat_GlobalVar(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GlobalVar>
        }
    }

    func GetValuesAsFunc(index: UInt32) : ?PackageFormat_Func {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_FUNC => Some(PackageFormat_Func(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Func>
        }
    }

    func GetValuesAsImportedVar(index: UInt32) : ?PackageFormat_ImportedVar {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_IMPORTEDVAR => Some(PackageFormat_ImportedVar(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ImportedVar>
        }
    }

    func GetValuesAsImportedFunc(index: UInt32) : ?PackageFormat_ImportedFunc {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_IMPORTEDFUNC => Some(PackageFormat_ImportedFunc(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ImportedFunc>
        }
    }

    func GetValuesAsBlock(index: UInt32) : ?PackageFormat_Block {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_BLOCK => Some(PackageFormat_Block(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Block>
        }
    }

    func GetValuesAsBlockGroup(index: UInt32) : ?PackageFormat_BlockGroup {
        let o : UInt16 = this.table.offset(VALUES)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetValuesType(index)) {
            case PackageFormat_ValueElem.ValueElem_BLOCKGROUP => Some(PackageFormat_BlockGroup(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_BlockGroup>
        }
    }

    func GetExprsType() : Array<Option<PackageFormat_ExpressionElem>> {
        let ELEMENT_STRIDE: UInt32 = 1
        let LENGTH: Int64 = this.table.getVectorLenBySlot(EXPRS_TYPE)
        var arr = Array<?PackageFormat_ExpressionElem>(LENGTH, repeat: None<PackageFormat_ExpressionElem>)
        let start: UInt32 = this.table.getVectorStartBySlot(EXPRS_TYPE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                EnumValuesPackageFormat_ExpressionElem(0)
            } else {
                EnumValuesPackageFormat_ExpressionElem(this.table.getUInt8(p))
            }
        }
        return arr
    }
    func GetExprs(index: Int32) : FlatBufferObject {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorLoc: UInt32 = this.table.getIndirect(UInt32(o) + this.table.pos)
        let vectorStart = vectorLoc + 4
        if (o == 0) {
            FlatBufferObject(Array<UInt8>(), 0)
        } else {
            table.getUnion(vectorStart + UInt32(index) * 4)
        }
    }
    func GetExprsSize(): Int64 {
        table.getVectorLenBySlot(EXPRS_TYPE)
    }
    func GetExprsType(index: UInt32): PackageFormat_ExpressionElem {
        let start = this.table.getVectorStartBySlot(EXPRS_TYPE)
        EnumValuesPackageFormat_ExpressionElem(this.table.getUInt8(start + index))
    }

    func GetExprsAsUnaryExpression(index: UInt32) : ?PackageFormat_UnaryExpression {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_UNARYEXPRESSION => Some(PackageFormat_UnaryExpression(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_UnaryExpression>
        }
    }

    func GetExprsAsBinaryExpression(index: UInt32) : ?PackageFormat_BinaryExpression {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_BINARYEXPRESSION => Some(PackageFormat_BinaryExpression(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_BinaryExpression>
        }
    }

    func GetExprsAsConstant(index: UInt32) : ?PackageFormat_Constant {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_CONSTANT => Some(PackageFormat_Constant(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Constant>
        }
    }

    func GetExprsAsAllocate(index: UInt32) : ?PackageFormat_Allocate {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_ALLOCATE => Some(PackageFormat_Allocate(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Allocate>
        }
    }

    func GetExprsAsLoad(index: UInt32) : ?PackageFormat_Load {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_LOAD => Some(PackageFormat_Load(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Load>
        }
    }

    func GetExprsAsStore(index: UInt32) : ?PackageFormat_Store {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_STORE => Some(PackageFormat_Store(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Store>
        }
    }

    func GetExprsAsGetElementRef(index: UInt32) : ?PackageFormat_GetElementRef {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTREF => Some(PackageFormat_GetElementRef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetElementRef>
        }
    }

    func GetExprsAsGetElementByName(index: UInt32) : ?PackageFormat_GetElementByName {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETELEMENTBYNAME => Some(PackageFormat_GetElementByName(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetElementByName>
        }
    }

    func GetExprsAsStoreElementRef(index: UInt32) : ?PackageFormat_StoreElementRef {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTREF => Some(PackageFormat_StoreElementRef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_StoreElementRef>
        }
    }

    func GetExprsAsStoreElementByName(index: UInt32) : ?PackageFormat_StoreElementByName {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_STOREELEMENTBYNAME => Some(PackageFormat_StoreElementByName(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_StoreElementByName>
        }
    }

    func GetExprsAsApply(index: UInt32) : ?PackageFormat_Apply {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_APPLY => Some(PackageFormat_Apply(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Apply>
        }
    }

    func GetExprsAsInvoke(index: UInt32) : ?PackageFormat_Invoke {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INVOKE => Some(PackageFormat_Invoke(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Invoke>
        }
    }

    func GetExprsAsTypeCast(index: UInt32) : ?PackageFormat_TypeCast {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_TYPECAST => Some(PackageFormat_TypeCast(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_TypeCast>
        }
    }

    func GetExprsAsInstanceOf(index: UInt32) : ?PackageFormat_InstanceOf {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INSTANCEOF => Some(PackageFormat_InstanceOf(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_InstanceOf>
        }
    }

    func GetExprsAsBox(index: UInt32) : ?PackageFormat_Box {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_BOX => Some(PackageFormat_Box(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Box>
        }
    }

    func GetExprsAsUnBox(index: UInt32) : ?PackageFormat_UnBox {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_UNBOX => Some(PackageFormat_UnBox(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_UnBox>
        }
    }

    func GetExprsAsGoTo(index: UInt32) : ?PackageFormat_GoTo {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GOTO => Some(PackageFormat_GoTo(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GoTo>
        }
    }

    func GetExprsAsBranch(index: UInt32) : ?PackageFormat_Branch {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_BRANCH => Some(PackageFormat_Branch(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Branch>
        }
    }

    func GetExprsAsMultiBranch(index: UInt32) : ?PackageFormat_MultiBranch {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_MULTIBRANCH => Some(PackageFormat_MultiBranch(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_MultiBranch>
        }
    }

    func GetExprsAsExit(index: UInt32) : ?PackageFormat_Exit {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_EXIT => Some(PackageFormat_Exit(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Exit>
        }
    }

    func GetExprsAsRaiseException(index: UInt32) : ?PackageFormat_RaiseException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_RAISEEXCEPTION => Some(PackageFormat_RaiseException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RaiseException>
        }
    }

    func GetExprsAsApplyWithException(index: UInt32) : ?PackageFormat_ApplyWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_APPLYWITHEXCEPTION => Some(PackageFormat_ApplyWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ApplyWithException>
        }
    }

    func GetExprsAsInvokeWithException(index: UInt32) : ?PackageFormat_InvokeWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INVOKEWITHEXCEPTION => Some(PackageFormat_InvokeWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_InvokeWithException>
        }
    }

    func GetExprsAsIntOpWithException(index: UInt32) : ?PackageFormat_IntOpWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INTOPWITHEXCEPTION => Some(PackageFormat_IntOpWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IntOpWithException>
        }
    }

    func GetExprsAsTypeCastWithException(index: UInt32) : ?PackageFormat_TypeCastWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_TYPECASTWITHEXCEPTION => Some(PackageFormat_TypeCastWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_TypeCastWithException>
        }
    }

    func GetExprsAsIntrinsicWithException(index: UInt32) : ?PackageFormat_IntrinsicWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INTRINSICWITHEXCEPTION => Some(PackageFormat_IntrinsicWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_IntrinsicWithException>
        }
    }

    func GetExprsAsAllocateWithException(index: UInt32) : ?PackageFormat_AllocateWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_ALLOCATEWITHEXCEPTION => Some(PackageFormat_AllocateWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_AllocateWithException>
        }
    }

    func GetExprsAsRawArrayAllocateWithException(index: UInt32) : ?PackageFormat_RawArrayAllocateWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATEWITHEXCEPTION => Some(PackageFormat_RawArrayAllocateWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RawArrayAllocateWithException>
        }
    }

    func GetExprsAsSpawnWithException(index: UInt32) : ?PackageFormat_SpawnWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_SPAWNWITHEXCEPTION => Some(PackageFormat_SpawnWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_SpawnWithException>
        }
    }

    func GetExprsAsTuple(index: UInt32) : ?PackageFormat_Tuple {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_TUPLE => Some(PackageFormat_Tuple(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Tuple>
        }
    }

    func GetExprsAsField(index: UInt32) : ?PackageFormat_Field {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_FIELD => Some(PackageFormat_Field(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Field>
        }
    }

    func GetExprsAsFieldByName(index: UInt32) : ?PackageFormat_FieldByName {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_FIELDBYNAME => Some(PackageFormat_FieldByName(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_FieldByName>
        }
    }

    func GetExprsAsRawArrayAllocate(index: UInt32) : ?PackageFormat_RawArrayAllocate {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYALLOCATE => Some(PackageFormat_RawArrayAllocate(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RawArrayAllocate>
        }
    }

    func GetExprsAsRawArrayLiteralInit(index: UInt32) : ?PackageFormat_RawArrayLiteralInit {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYLITERALINIT => Some(PackageFormat_RawArrayLiteralInit(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RawArrayLiteralInit>
        }
    }

    func GetExprsAsRawArrayInitByValue(index: UInt32) : ?PackageFormat_RawArrayInitByValue {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_RAWARRAYINITBYVALUE => Some(PackageFormat_RawArrayInitByValue(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_RawArrayInitByValue>
        }
    }

    func GetExprsAsVArray(index: UInt32) : ?PackageFormat_VArray {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_VARRAY => Some(PackageFormat_VArray(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VArray>
        }
    }

    func GetExprsAsVArrayBd(index: UInt32) : ?PackageFormat_VArrayBd {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_VARRAYBD => Some(PackageFormat_VArrayBd(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_VArrayBd>
        }
    }

    func GetExprsAsGetException(index: UInt32) : ?PackageFormat_GetException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETEXCEPTION => Some(PackageFormat_GetException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetException>
        }
    }

    func GetExprsAsIntrinsic(index: UInt32) : ?PackageFormat_Intrinsic {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INTRINSIC => Some(PackageFormat_Intrinsic(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Intrinsic>
        }
    }

    func GetExprsAsIf(index: UInt32) : ?PackageFormat_If {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_IF => Some(PackageFormat_If(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_If>
        }
    }

    func GetExprsAsLoop(index: UInt32) : ?PackageFormat_Loop {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_LOOP => Some(PackageFormat_Loop(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Loop>
        }
    }

    func GetExprsAsForInRange(index: UInt32) : ?PackageFormat_ForInRange {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_FORINRANGE => Some(PackageFormat_ForInRange(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ForInRange>
        }
    }

    func GetExprsAsForInIter(index: UInt32) : ?PackageFormat_ForInIter {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_FORINITER => Some(PackageFormat_ForInIter(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ForInIter>
        }
    }

    func GetExprsAsForInClosedRange(index: UInt32) : ?PackageFormat_ForInClosedRange {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_FORINCLOSEDRANGE => Some(PackageFormat_ForInClosedRange(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ForInClosedRange>
        }
    }

    func GetExprsAsDebug(index: UInt32) : ?PackageFormat_Debug {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_DEBUG => Some(PackageFormat_Debug(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Debug>
        }
    }

    func GetExprsAsSpawn(index: UInt32) : ?PackageFormat_Spawn {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_SPAWN => Some(PackageFormat_Spawn(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Spawn>
        }
    }

    func GetExprsAsLambda(index: UInt32) : ?PackageFormat_Lambda {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_LAMBDA => Some(PackageFormat_Lambda(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_Lambda>
        }
    }

    func GetExprsAsInvokeStatic(index: UInt32) : ?PackageFormat_InvokeStatic {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATIC => Some(PackageFormat_InvokeStatic(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_InvokeStatic>
        }
    }

    func GetExprsAsInvokeStaticWithException(index: UInt32) : ?PackageFormat_InvokeStaticWithException {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_INVOKESTATICWITHEXCEPTION => Some(PackageFormat_InvokeStaticWithException(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_InvokeStaticWithException>
        }
    }

    func GetExprsAsGetInstantiateValue(index: UInt32) : ?PackageFormat_GetInstantiateValue {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETINSTANTIATEVALUE => Some(PackageFormat_GetInstantiateValue(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetInstantiateValue>
        }
    }

    func GetExprsAsTransformToConcrete(index: UInt32) : ?PackageFormat_TransformToConcrete {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOCONCRETE => Some(PackageFormat_TransformToConcrete(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_TransformToConcrete>
        }
    }

    func GetExprsAsTransformToGeneric(index: UInt32) : ?PackageFormat_TransformToGeneric {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_TRANSFORMTOGENERIC => Some(PackageFormat_TransformToGeneric(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_TransformToGeneric>
        }
    }

    func GetExprsAsUnBoxToRef(index: UInt32) : ?PackageFormat_UnBoxToRef {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_UNBOXTOREF => Some(PackageFormat_UnBoxToRef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_UnBoxToRef>
        }
    }

    func GetExprsAsGetRTTI(index: UInt32) : ?PackageFormat_GetRTTI {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETRTTI => Some(PackageFormat_GetRTTI(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetRTTI>
        }
    }

    func GetExprsAsGetRTTIStatic(index: UInt32) : ?PackageFormat_GetRTTIStatic {
        let o : UInt16 = this.table.offset(EXPRS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetExprsType(index)) {
            case PackageFormat_ExpressionElem.ExpressionElem_GETRTTISTATIC => Some(PackageFormat_GetRTTIStatic(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_GetRTTIStatic>
        }
    }

    func GetDefsType() : Array<Option<PackageFormat_CustomTypeDefElem>> {
        let ELEMENT_STRIDE: UInt32 = 1
        let LENGTH: Int64 = this.table.getVectorLenBySlot(DEFS_TYPE)
        var arr = Array<?PackageFormat_CustomTypeDefElem>(LENGTH, repeat: None<PackageFormat_CustomTypeDefElem>)
        let start: UInt32 = this.table.getVectorStartBySlot(DEFS_TYPE)
        for (i in 0..LENGTH) {
            let p: UInt32 = start + UInt32(i) * ELEMENT_STRIDE
            arr[i] = if (this.table.getIndirect(p) == p) {
                EnumValuesPackageFormat_CustomTypeDefElem(0)
            } else {
                EnumValuesPackageFormat_CustomTypeDefElem(this.table.getUInt8(p))
            }
        }
        return arr
    }
    func GetDefs(index: Int32) : FlatBufferObject {
        let o : UInt16 = this.table.offset(DEFS)
        let vectorLoc: UInt32 = this.table.getIndirect(UInt32(o) + this.table.pos)
        let vectorStart = vectorLoc + 4
        if (o == 0) {
            FlatBufferObject(Array<UInt8>(), 0)
        } else {
            table.getUnion(vectorStart + UInt32(index) * 4)
        }
    }
    func GetDefsSize(): Int64 {
        table.getVectorLenBySlot(DEFS_TYPE)
    }
    func GetDefsType(index: UInt32): PackageFormat_CustomTypeDefElem {
        let start = this.table.getVectorStartBySlot(DEFS_TYPE)
        EnumValuesPackageFormat_CustomTypeDefElem(this.table.getUInt8(start + index))
    }

    func GetDefsAsEnumDef(index: UInt32) : ?PackageFormat_EnumDef {
        let o : UInt16 = this.table.offset(DEFS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetDefsType(index)) {
            case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_ENUMDEF => Some(PackageFormat_EnumDef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_EnumDef>
        }
    }

    func GetDefsAsStructDef(index: UInt32) : ?PackageFormat_StructDef {
        let o : UInt16 = this.table.offset(DEFS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetDefsType(index)) {
            case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_STRUCTDEF => Some(PackageFormat_StructDef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_StructDef>
        }
    }

    func GetDefsAsClassDef(index: UInt32) : ?PackageFormat_ClassDef {
        let o : UInt16 = this.table.offset(DEFS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetDefsType(index)) {
            case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_CLASSDEF => Some(PackageFormat_ClassDef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ClassDef>
        }
    }

    func GetDefsAsExtendDef(index: UInt32) : ?PackageFormat_ExtendDef {
        let o : UInt16 = this.table.offset(DEFS)
        let vectorStart = this.table.getIndirect(UInt32(o) + this.table.pos)
        match (this.GetDefsType(index)) {
            case PackageFormat_CustomTypeDefElem.CustomTypeDefElem_EXTENDDEF => Some(PackageFormat_ExtendDef(this.table.bytes, vectorStart + (index + 1) * 4))
            case _ => None<PackageFormat_ExtendDef>
        }
    }

    func GetPackageInitFunc(): UInt32 {
        return this.table.getUInt32Slot(PACKAGEINITFUNC, 0)
    }
    func GetPhase(): PackageFormat_Phase {
        let o : UInt32 = UInt32(this.table.offset(PHASE))
        let off : UInt32 = o + this.table.pos
        return if (o == 0) {
            PackageFormat_Phase.Phase_RAW
        } else {
            EnumValuesPackageFormat_Phase(this.table.getUInt8(off))
        }
    }
    func GetPackageLiteralInitFunc(): UInt32 {
        return this.table.getUInt32Slot(PACKAGELITERALINITFUNC, 0)
    }
    func GetMaxImportedValueId(): UInt32 {
        return this.table.getUInt32Slot(MAXIMPORTEDVALUEID, 0)
    }
    func GetMaxImportedStructId(): UInt32 {
        return this.table.getUInt32Slot(MAXIMPORTEDSTRUCTID, 0)
    }
    func GetMaxImportedClassId(): UInt32 {
        return this.table.getUInt32Slot(MAXIMPORTEDCLASSID, 0)
    }
    func GetMaxImportedEnumId(): UInt32 {
        return this.table.getUInt32Slot(MAXIMPORTEDENUMID, 0)
    }
    func GetMaxImportedExtendId(): UInt32 {
        return this.table.getUInt32Slot(MAXIMPORTEDEXTENDID, 0)
    }
    static func startCHIRPackage(builder: Builder): Unit { builder.startObject(19) }
    static func addName(name: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(0, name, 0)
    }
    static func addPath(path: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(1, path, 0)
    }
    static func addPkgAccessLevel(pkgAccessLevel: PackageFormat_PackageAccessLevel, builder: Builder) {
        builder.prependUInt8Slot(2, EnumPackageFormat_PackageAccessLevelValues(pkgAccessLevel), 0)
    }
    static func addTypesTypeVector(typesType: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(3, typesType, 0)
    }
    static func addTypesVector(types: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(4, types, 0)
    }
    static func addValuesTypeVector(valuesType: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(5, valuesType, 0)
    }
    static func addValuesVector(values: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(6, values, 0)
    }
    static func addExprsTypeVector(exprsType: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(7, exprsType, 0)
    }
    static func addExprsVector(exprs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(8, exprs, 0)
    }
    static func addDefsTypeVector(defsType: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(9, defsType, 0)
    }
    static func addDefsVector(defs: UInt32, builder: Builder) {
        builder.prependUOffsetTSlot(10, defs, 0)
    }
    static func addPackageInitFunc(packageInitFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(11, packageInitFunc, 0)
    }
    static func addPhase(phase: PackageFormat_Phase, builder: Builder) {
        builder.prependUInt8Slot(12, EnumPackageFormat_PhaseValues(phase), 0)
    }
    static func addPackageLiteralInitFunc(packageLiteralInitFunc: UInt32, builder: Builder) {
        builder.prependUInt32Slot(13, packageLiteralInitFunc, 0)
    }
    static func addMaxImportedValueId(maxImportedValueId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(14, maxImportedValueId, 0)
    }
    static func addMaxImportedStructId(maxImportedStructId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(15, maxImportedStructId, 0)
    }
    static func addMaxImportedClassId(maxImportedClassId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(16, maxImportedClassId, 0)
    }
    static func addMaxImportedEnumId(maxImportedEnumId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(17, maxImportedEnumId, 0)
    }
    static func addMaxImportedExtendId(maxImportedExtendId: UInt32, builder: Builder) {
        builder.prependUInt32Slot(18, maxImportedExtendId, 0)
    }
    static func endCHIRPackage(builder: Builder): UInt32 {return builder.endObject()}
    static func createCHIRPackage(
        builder: Builder,
        name: UInt32,
        path: UInt32,
        pkgAccessLevel: PackageFormat_PackageAccessLevel,
        typesType: UInt32,
        types: UInt32,
        valuesType: UInt32,
        values: UInt32,
        exprsType: UInt32,
        exprs: UInt32,
        defsType: UInt32,
        defs: UInt32,
        packageInitFunc: UInt32,
        phase: PackageFormat_Phase,
        packageLiteralInitFunc: UInt32,
        maxImportedValueId: UInt32,
        maxImportedStructId: UInt32,
        maxImportedClassId: UInt32,
        maxImportedEnumId: UInt32,
        maxImportedExtendId: UInt32
    ): UInt32 {
        PackageFormat_CHIRPackage.startCHIRPackage(builder)
        PackageFormat_CHIRPackage.addMaxImportedExtendId(maxImportedExtendId, builder)
        PackageFormat_CHIRPackage.addMaxImportedEnumId(maxImportedEnumId, builder)
        PackageFormat_CHIRPackage.addMaxImportedClassId(maxImportedClassId, builder)
        PackageFormat_CHIRPackage.addMaxImportedStructId(maxImportedStructId, builder)
        PackageFormat_CHIRPackage.addMaxImportedValueId(maxImportedValueId, builder)
        PackageFormat_CHIRPackage.addPackageLiteralInitFunc(packageLiteralInitFunc, builder)
        PackageFormat_CHIRPackage.addPhase(phase, builder)
        PackageFormat_CHIRPackage.addPackageInitFunc(packageInitFunc, builder)
        PackageFormat_CHIRPackage.addDefsVector(defs, builder)
        PackageFormat_CHIRPackage.addDefsTypeVector(defsType, builder)
        PackageFormat_CHIRPackage.addExprsVector(exprs, builder)
        PackageFormat_CHIRPackage.addExprsTypeVector(exprsType, builder)
        PackageFormat_CHIRPackage.addValuesVector(values, builder)
        PackageFormat_CHIRPackage.addValuesTypeVector(valuesType, builder)
        PackageFormat_CHIRPackage.addTypesVector(types, builder)
        PackageFormat_CHIRPackage.addTypesTypeVector(typesType, builder)
        PackageFormat_CHIRPackage.addPkgAccessLevel(pkgAccessLevel, builder)
        PackageFormat_CHIRPackage.addPath(path, builder)
        PackageFormat_CHIRPackage.addName(name, builder)
        return PackageFormat_CHIRPackage.endCHIRPackage(builder)
    }
}

